[{"title":"AnyIO-æºç è§£è¯»","path":"/2025/09/01/AnyIO-æºç è§£è¯»/","content":"AnyIO æ˜¯ä¸€ä¸ªâ€œåç«¯æ— å…³â€çš„å¼‚æ­¥å¹¶å‘ä¸ç½‘ç»œåº“ï¼šå¯¹ä¸Šæä¾›ç»Ÿä¸€çš„é«˜å±‚ APIï¼ˆä»»åŠ¡ç»„ã€å–æ¶ˆåŸŸã€æµã€åŒæ­¥åŸè¯­ã€çº¿ç¨‹&#x2F;è¿›ç¨‹æ¡¥ã€å­è¿›ç¨‹ã€æ–‡ä»¶ I&#x2F;Oã€ä¿¡å·å¤„ç†ã€pytest é›†æˆï¼‰ï¼Œå¯¹ä¸‹å¯åœ¨ asyncio æˆ– Trio ä¸Šè¿è¡Œã€‚å®ƒå°† Trio çš„ç»“æ„åŒ–å¹¶å‘ï¼ˆStructured Concurrency, SCï¼‰ æ¨¡å‹ï¼ˆä»»åŠ¡ç»„ã€å–æ¶ˆä¼ æ’­ã€å¤±è´¥å³å–æ¶ˆï¼‰æ¨å¹¿åˆ° asyncioï¼Œä»è€Œè®©åº”ç”¨ä¸åº“åœ¨ä¸¤å¤§ç”Ÿæ€é—´èƒ½â€œä¸€æ¬¡ç¼–å†™ï¼Œä¸¤å¤„è¿è¡Œâ€ã€‚ æ ¸å¿ƒå–ç‚¹ï¼š ç»Ÿä¸€ APIï¼Œéšè—åç«¯å·®å¼‚ Trio é£æ ¼çš„ç»“æ„åŒ–å¹¶å‘ï¼ˆTaskGroupã€CancelScopeï¼‰ å¯é çš„ç½‘ç»œ&#x2F;æµæŠ½è±¡ï¼ˆTCP&#x2F;UDP&#x2F;UNIXã€TLSã€å†…å­˜æµï¼‰ã€Happy Eyeballs è¿æ¥ç­–ç•¥ ç®€æ˜çš„çº¿ç¨‹&#x2F;è¿›ç¨‹æ¡¥ï¼ˆto_thread&#x2F;from_thread + CapacityLimiterï¼‰ ä¸€æµçš„æµ‹è¯•ä½“éªŒï¼ˆpytest æ’ä»¶ï¼šåŒä¸€å¥—æµ‹è¯•å¯¹ä¸¤ä¸ªåç«¯è·‘ï¼‰ ç›®å½•ç»“æ„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950â”‚ from_thread.pyâ”‚ lowlevel.pyâ”‚ py.typedâ”‚ pytest_plugin.pyâ”‚ to_interpreter.pyâ”‚ to_process.pyâ”‚ to_thread.pyâ”‚ __init__.pyâ”‚â”œâ”€abcâ”‚ _eventloop.pyâ”‚ _resources.pyâ”‚ _sockets.pyâ”‚ _streams.pyâ”‚ _subprocesses.pyâ”‚ _tasks.pyâ”‚ _testing.pyâ”‚ __init__.pyâ”‚â”œâ”€streamsâ”‚ buffered.pyâ”‚ file.pyâ”‚ memory.pyâ”‚ stapled.pyâ”‚ text.pyâ”‚ tls.pyâ”‚ __init__.pyâ”‚â”œâ”€_backendsâ”‚ _asyncio.pyâ”‚ _trio.pyâ”‚ __init__.pyâ”‚â””â”€_core _asyncio_selector_thread.py _contextmanagers.py _eventloop.py _exceptions.py _fileio.py _resources.py _signals.py _sockets.py _streams.py _subprocesses.py _synchronization.py _tasks.py _tempfile.py _testing.py _typedattr.py __init__.py åç«¯é€‚é…ï¼ˆ_backendsï¼‰ _asyncio.py åæ§½ä¸€ä¸‹ï¼šæºä»£ç å§æ‰€æœ‰ç±»ã€å˜é‡ã€æ–¹æ³•éƒ½æ”¾åœ¨äº†è¿™ä¸ªæ–‡ä»¶é‡Œï¼Œå¯¼è‡´ä»£ç å®šä½å¾ˆå›°éš¾ï¼Œå¾’å¢ç†è§£éš¾åº¦ _asyncio.py çš„ä½œç”¨æ˜¯æŠŠ AnyIO çš„é€šç”¨åç«¯æŠ½è±¡ï¼ˆTaskGroupã€CancelScopeã€streamsã€thread&#x2F;portalã€å­è¿›ç¨‹ç­‰ï¼‰ç»‘å®šåˆ° asyncioï¼šä¹Ÿå°±æ˜¯æŠŠ AnyIO çš„è¯­ä¹‰ï¼ˆTrio é£æ ¼çš„ç»“æ„åŒ–å¹¶å‘ã€å–æ¶ˆåŸŸã€å¼‚å¸¸èšåˆã€æµæŠ½è±¡ã€çº¿ç¨‹æ¡¥ç­‰ï¼‰åœ¨ asyncio ä¸Šâ€œå®ç°å‡ºæ¥å¹¶ä¿®è¡¥ asyncio ä¸ AnyIO è¯­ä¹‰å·®å¼‚â€ 1234567891011121314151617181920if sys.version_info &gt;= (3, 11): from asyncio import Runner from typing import TypeVarTuple, Unpackelse: import contextvars import enum import signal from asyncio import coroutines, events, exceptions, tasks from exceptiongroup import BaseExceptionGroup from typing_extensions import TypeVarTuple, Unpack class _State(enum.Enum): CREATED = &quot;created&quot; INITIALIZED = &quot;initialized&quot; CLOSED = &quot;closed&quot; class Runner: # Copied from CPython 3.11 ... Runner å®ç°é¦–å…ˆæ˜¯ç›´æ¥å¤åˆ¶äº† CPython3.11 å¯¹äº Runner çš„å®ç°ï¼Œå¯¹é½ä½ç‰ˆæœ¬ python ayncio çš„å·®å¼‚æ€§ã€‚è¿™é‡Œåº”è¯¥æ˜¯å€Ÿé‰´äº† Trio çš„ä¸€äº›è®¾è®¡æ€æƒ³ï¼ŒAnyIO çš„å‡ºå‘ç‚¹ä¹Ÿæ˜¯æ•´åˆTrio å’Œ AsyncIO çš„ç”Ÿæ€ ä¸ºä»€ä¹ˆè¦æœ‰ Runnerï¼Ÿ æ˜¯ä¸ºäº†åœ¨â€œä¸€ä¸ªè¿›ç¨‹é‡Œå¤šæ¬¡è¿è¡Œä¸åŒé¡¶å±‚åç¨‹â€æ—¶ï¼Œä¾æ—§èƒ½ä¿æŒäº‹ä»¶å¾ªç¯å¤ç”¨ã€contextvars ä¸€è‡´ã€èµ„æºæ­£ç¡®å›æ”¶â€”â€”è¿™æ˜¯ä¹‹å‰çš„ asyncio.run() åšä¸åˆ°çš„ã€‚ ä¹‹å‰æ‰§è¡Œè¡Œä¸º 12asyncio.run(foo()) # è¿è¡Œå®Œå°±å½»åº•å…³é—­asyncio.run(bar()) # ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„å¾ªç¯ï¼Œcontextvars ä¹Ÿæ–­äº† æ—§ç‰ˆæœ¬è§£å†³æ–¹æ¡ˆ, ä¸»åŠ¨åˆ›å»ºäº‹ä»¶å¾ªç¯ï¼Œå¹¶ä¸€ç›´å¤ç”¨ loop æ¯æ¬¡ run_until_complete ä¼šæ¸…ç©ºä»»åŠ¡é˜Ÿåˆ—ï¼Œä½†å¾ªç¯æœ¬èº«è¿˜æ´»ç€ã€‚ å¦‚æœå¿˜äº† close()ï¼Œçº¿ç¨‹ç»“æŸæ—¶ä¼šè§¦å‘ â€œEvent loop is closedâ€ RuntimeErrorã€‚ 123456789101112131415import asyncio# ç¬¬ä¸€æ¬¡åˆå§‹åŒ–loop = asyncio.new_event_loop()# è®¾ä¸ºå…¨å±€é»˜è®¤asyncio.set_event_loop(loop) try: loop.run_until_complete(coro1()) loop.run_until_complete(coro2()) ...finally: loop.run_until_complete(loop.shutdown_asyncgens()) loop.run_until_complete(loop.shutdown_default_executor()) loop.close() è€Œ Runner å®ç° äº†ä»¥ä¸‹åŠŸèƒ½ ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼šä¸€æ¬¡åˆ›å»ºï¼Œå¯åå¤ runner.run(coro)ï¼Œäº‹ä»¶å¾ªç¯å’Œ contextvars.Context å¾—ä»¥å¤ç”¨ã€‚ ç»Ÿä¸€æ¸…ç†ï¼šç¦»å¼€ with è¯­å¥æ—¶è‡ªåŠ¨å…³é—­å¾ªç¯ã€ç»ˆç»“å¼‚æ­¥ç”Ÿæˆå™¨ã€åœæ­¢é»˜è®¤çº¿ç¨‹æ± ã€‚ å¯æ§ Ctrl-Cï¼šå†…ç½®ä¿¡å·å¤„ç†å™¨ï¼Œç¬¬ä¸€æ¬¡ Ctrl-C å‘ CancelledErrorï¼Œç¬¬äºŒæ¬¡ç«‹å³æŠ› KeyboardInterruptï¼Œé¿å…åƒµå°¸å¾ªç¯ã€‚ å¯é€‰ debug &#x2F; è‡ªå®šä¹‰ loop_factoryï¼šè°ƒè¯•ã€æ€§èƒ½è°ƒä¼˜æ›´æ–¹ä¾¿ 123456789import asyncioasync def hello(name): await asyncio.sleep(0.1) return f&quot;Hello &#123;name&#125;&quot;with asyncio.Runner() as runner: print(runner.run(hello(&quot;Alice&quot;))) print(runner.run(hello(&quot;Bob&quot;))) ä¸¤æ®µåç¨‹å…±ç”¨åŒä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œä¸”é€€å‡º with åè‡ªåŠ¨æ¸…ç†ã€‚ ä»»åŠ¡ç»„ä»»åŠ¡ç»„å®ç°äº†ç»“æ„åŒ–å¹¶å‘ï¼ˆå®ƒç¡®ä¿å¹¶å‘æ“ä½œå…·æœ‰æ˜ç¡®å®šä¹‰çš„åµŒå¥—ç”Ÿå‘½å‘¨æœŸï¼Œæ˜¯ä¸€ç§ç¼–ç¨‹èŒƒå¼ï¼‰ï¼Œä»»åŠ¡ç»„å……å½“å¹¶å‘ä»»åŠ¡çš„ç›‘ç£è€… AnyIO ä¸­ç»“æ„åŒ–å¹¶å‘çš„å…³é”®åŸåˆ™ï¼š å­ä»»åŠ¡ä¸èƒ½è¶…è¿‡å…¶çˆ¶ä»»åŠ¡çš„ä½œç”¨åŸŸ å­ä»»åŠ¡ä¸­çš„é”™è¯¯ä¼šä¼ æ’­åˆ°çˆ¶ä»»åŠ¡ å–æ¶ˆä»çˆ¶çº§ä¼ æ’­åˆ°å­çº§ æ‰€æœ‰è¡ç”Ÿä»»åŠ¡å¿…é¡»åœ¨çˆ¶çº§é€€å‡ºä¹‹å‰å®Œæˆ å…³é”®ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215class TaskGroup(abc.TaskGroup): &quot;&quot;&quot; ä¸€ä¸ªâ€œå¯ç­‰å¾…â€çš„ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼š with è¯­å¥å—é‡Œå¯ä»¥ start() / start_soon() æ‰”å­ä»»åŠ¡ï¼Œ ç¦»å¼€ with æ—¶ä¼šè‡ªåŠ¨ï¼š - ç­‰å¾…æ‰€æœ‰å­ä»»åŠ¡ç»“æŸ - è‹¥ä»»ä½•å­ä»»åŠ¡æŠ›å¼‚å¸¸ï¼Œåˆ™å–æ¶ˆå…¶ä½™ä»»åŠ¡ - æŠŠå¼‚å¸¸é‡æ–°æŠ›å‡ºç»™è°ƒç”¨è€… &quot;&quot;&quot; # ---------- åˆå§‹åŒ– ---------- def __init__(self) -&gt; None: self._active = False # æ ‡è®°å½“å‰æ˜¯å¦å·²è¿›å…¥ with å— self._exiting = False # æ­£åœ¨é€€å‡º withï¼ˆé˜²æ­¢é‡å¤å–æ¶ˆï¼‰ self._exceptions: list[BaseException] = [] # æ”¶é›†å­ä»»åŠ¡å¼‚å¸¸ self._tasks: set[asyncio.Task] = set() # å½“å‰æ´»è·ƒçš„å­ä»»åŠ¡ self._cancel_scope: CancelScope | None = None # ç”¨æ¥çº§è”å–æ¶ˆ # â†‘ åˆ©ç”¨ asyncio.Future åšâ€œäº‹ä»¶é€šçŸ¥â€ï¼š # å½“æœ€åä¸€ä¸ªå­ä»»åŠ¡å®Œæˆæ—¶ set_result(None)ï¼Œä¸»å¾ªç¯å°±é†’æ¥ç»§ç»­ # ---------- è¿›å…¥ with è¯­å¥ ---------- async def __aenter__(self) -&gt; TaskGroup: self._cancel_scope = CancelScope() # åˆ›å»ºæ ¹å–æ¶ˆä½œç”¨åŸŸ self._active = True return self # ---------- é€€å‡º with è¯­å¥ ---------- async def __aexit__(self, exc_type, exc_val, exc_tb): try: # 1ï¸âƒ£ å¦‚æœ with å—æœ¬èº«æŠ›äº†å¼‚å¸¸ï¼Œå…ˆæŠŠä»»åŠ¡ç»„å–æ¶ˆ if exc_val is not None: self.cancel_scope.cancel() # å¦‚æœæ˜¯â€œéå–æ¶ˆâ€å¼‚å¸¸ï¼Œè®°å½•ä¸‹æ¥ if not isinstance(exc_val, CancelledError): self._exceptions.append(exc_val) loop = get_running_loop() try: if self._tasks: # è¿˜æœ‰å­ä»»åŠ¡æ²¡è·‘å®Œ with CancelScope() as wait_scope: # æ–°å»ºä¸€ä¸ªâ€œç­‰å¾…ä½œç”¨åŸŸâ€ while self._tasks: # è½®è¯¢ç›´åˆ°å…¨éƒ¨ç»“æŸ self._on_completed_fut = loop.create_future() try: await self._on_completed_fut # æŒ‚èµ·ï¼Œç›´åˆ°æœ€åä¸€ä¸ªä»»åŠ¡ done except CancelledError as exc: # ğŸ”¥ å…³é”®ç‚¹ï¼šå±è”½åç»­å–æ¶ˆï¼Œé˜²æ­¢å¾ªç¯å–æ¶ˆé£æš´ wait_scope.shield = True self.cancel_scope.cancel() # å¦‚æœä¹‹å‰æ²¡æœ‰å¼‚å¸¸ï¼ŒæŠŠè¿™æ¬¡å–æ¶ˆè®°å½•ä¸ºâ€œä¸»å› â€ if exc_val is None or ( isinstance(exc_val, CancelledError) and not is_anyio_cancellation(exc) ): exc_val = exc self._on_completed_fut = None else: # æ²¡æœ‰å­ä»»åŠ¡ä¹Ÿè¦è‡³å°‘åšä¸€æ¬¡ checkpoint await AsyncIOBackend.cancel_shielded_checkpoint() self._active = False # 2ï¸âƒ£ æŠŠæ‰€æœ‰å­å¼‚å¸¸æ‰“åŒ…æˆ BaseExceptionGroup if self._exceptions: raise BaseExceptionGroup( &quot;unhandled errors in a TaskGroup&quot;, self._exceptions ) from None elif exc_val: raise exc_val except BaseException as exc: # å¦‚æœ cancel_scope å†³å®šåæ‰å¼‚å¸¸ï¼Œè¿”å› Trueï¼ˆä¸ç»§ç»­æŠ›ï¼‰ if self.cancel_scope.__exit__(type(exc), exc, exc.__traceback__): return True raise finally: # é¿å…å¾ªç¯å¼•ç”¨ del exc_val, exc_tb, self._exceptions def start_soon( self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None, ) -&gt; None: task = self._spawn(func, args, name, None) async def start( self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None, ) -&gt; Any: &quot;&quot;&quot; ç«‹å³å¯åŠ¨å­ä»»åŠ¡ï¼Œç­‰å¾…å®ƒäº§å‡ºç¬¬ä¸€ä¸ªå€¼åè¿”å›ï¼› è‹¥å­ä»»åŠ¡å¯åŠ¨ç¬é—´çˆ†ç‚¸ï¼Œåˆ™ä¿æŠ¤è°ƒç”¨è€…ä¸è¢«ä»»åŠ¡ç»„çº§è”å–æ¶ˆæ·¹æ²¡ã€‚ &quot;&quot;&quot; if not self._active: raise RuntimeError(&quot;å¿…é¡»åœ¨ TaskGroup æ´»è·ƒæœŸ start&quot;) future: asyncio.Future = asyncio.Future() # ç”¨æ¥ä¼ å›â€œé¦–å€¼â€ task = self._spawn(func, args, name, future) # ç»‘å®š future # ğŸ”¥ å…³é”®ï¼šå±è”½å–æ¶ˆä½œç”¨åŸŸ # å¦‚æœ task åœ¨ yield ç¬¬ä¸€ä¸ªå€¼å‰å°±æŠ›å¼‚å¸¸ï¼Œä»»åŠ¡ç»„ä¼šç«‹å³å–æ¶ˆï¼Œ # å¯¼è‡´æœ¬æ–¹æ³•ä¹Ÿè¢« CancelledError æ‰“æ–­ï¼Œæ— æ³•æŠŠåŸå§‹å¼‚å¸¸äº¤ç»™è°ƒç”¨è€…ã€‚ try: return await future except asyncio.CancelledError: # 1. å…ˆç»™è‚‡äº‹ä»»åŠ¡å‘å–æ¶ˆ task.cancel() # 2. ç”¨ shield=True çš„ CancelScope ä¿æŠ¤å½“å‰æ ˆå¸§ # é¿å…ä»»åŠ¡ç»„çš„çº§è”å–æ¶ˆæŠŠçˆ¶ä»»åŠ¡ä¹Ÿæ€æ‰ with CancelScope(shield=True), suppress(asyncio.CancelledError): await task # ç­‰å®ƒçœŸæ­£ç»“æŸï¼Œåæ‰å†…éƒ¨ CancelledError raise # æŠŠçœŸæ­£çš„å¼‚å¸¸é‡æ–°æŠ›ç»™è°ƒç”¨è€… # ---------- å†…éƒ¨ï¼šçœŸæ­£åˆ›å»º task ---------- def _spawn( self, func: Callable[..., Awaitable[Any]], args: tuple, name: object, task_status_future: asyncio.Future | None = None, ) -&gt; asyncio.Task: &quot;&quot;&quot; task_status_future ç”¨äº `start()` åè®®ï¼š - å­ä»»åŠ¡è°ƒç”¨ task_status.started(value) ä¼š set_result(value) - å­ä»»åŠ¡å´©æºƒæ—¶ä¼š set_exception(...) &quot;&quot;&quot; def task_done(_task: asyncio.Task) -&gt; None: # 1ï¸âƒ£ æ¸…ç† bookkeeping task_state = _task_states[_task] # é€šè¿‡å¼±å¼•ç”¨æ˜ å°„æ‹¿åˆ° TaskState task_state.cancel_scope._tasks.remove(_task) self._tasks.remove(_task) del _task_states[_task] # 2ï¸âƒ£ å¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªä»»åŠ¡ï¼Œå«é†’ __aexit__ é‡Œçš„ while if self._on_completed_fut is not None and not self._tasks: try: self._on_completed_fut.set_result(None) except asyncio.InvalidStateError: pass # 3ï¸âƒ£ æ”¶é›†å¼‚å¸¸ try: exc = _task.exception() except CancelledError as e: # æŠŠé“¾å¼ CancelledError å‹å¹³ while isinstance(e.__context__, CancelledError): e = e.__context__ exc = e if exc is not None: # å¦‚æœ task_status_future å·²ç»è¢«å–æ¶ˆï¼ˆhost task å´©æºƒï¼‰ï¼Œç›´æ¥è·³è¿‡ if task_status_future is not None and task_status_future.cancelled(): return # æ­£å¸¸è®°å½•å¼‚å¸¸ or è½¬äº¤ç»™ task_status_future if task_status_future is None or task_status_future.done(): if not isinstance(exc, CancelledError): self._exceptions.append(exc) if not self.cancel_scope._effectively_cancelled: self.cancel_scope.cancel() else: task_status_future.set_exception(exc) elif task_status_future is not None and not task_status_future.done(): # å­ä»»åŠ¡æ²¡è°ƒç”¨ task_status.started() task_status_future.set_exception( RuntimeError(&quot;Child exited without calling task_status.started()&quot;) ) # 4ï¸âƒ£ åˆ›å»º asyncio.Task if not self._active: raise RuntimeError(&quot;TaskGroup æœªæ¿€æ´»&quot;) kwargs = &#123;&#125; if task_status_future: parent_id = id(current_task()) kwargs[&quot;task_status&quot;] = _AsyncioTaskStatus( task_status_future, id(self.cancel_scope._host_task) ) else: parent_id = id(self.cancel_scope._host_task) coro = func(*args, **kwargs) if not iscoroutine(coro): raise TypeError(&quot;æœŸæœ›åç¨‹å¯¹è±¡&quot;) name = get_callable_name(func) if name is None else str(name) loop = asyncio.get_running_loop() # æ”¯æŒè‡ªå®šä¹‰ task factoryï¼ˆå¦‚ eager taskï¼‰ if ( (factory := loop.get_task_factory()) and getattr(factory, &quot;__code__&quot;, None) is _eager_task_factory_code and (closure := getattr(factory, &quot;__closure__&quot;, None)) ): custom_task_constructor = closure[0].cell_contents task = custom_task_constructor(coro, loop=loop, name=name) else: task = create_task(coro, name=name) # æŠŠ task æŒ‚åˆ° cancel_scope çš„ç§æœ‰é›†åˆé‡Œï¼Œå®ç°çº§è”å–æ¶ˆ _task_states[task] = TaskState( parent_id=parent_id, cancel_scope=self.cancel_scope ) self.cancel_scope._tasks.add(task) # è®© cancel_scope.cancel() èƒ½éå† self._tasks.add(task) task.add_done_callback(task_done) return task ä¸¤ä¸ªæ–¹æ³• start_soon ä¸ç­‰å¾…ä»»åŠ¡æ‰§è¡Œç«‹å³è¿”å›ï¼Œæ‰€ä»¥æ— æ³•ä»ç”Ÿæˆçš„ä»»åŠ¡ä¸­è·å–è¿”å›å€¼ï¼Œä¹Ÿä¸çŸ¥é“ä»»åŠ¡ä½•æ—¶çœŸæ­£å¼€å§‹è¿è¡Œã€‚startç«‹å³æ‰§è¡Œï¼Œå¯ä»¥ä»ç”Ÿæˆçš„ä»»åŠ¡è¿”å›ä¸€ä¸ªå€¼ ä»»åŠ¡çŠ¶æ€è¡¨ä¸å¼‚å¸¸èšåˆAnyIO è¦åœ¨ asyncio ä¸Šæä¾› Trio é£æ ¼â€œç»“æ„åŒ–å¹¶å‘â€çš„è¯­ä¹‰ï¼šä»»ä½•å­ä»»åŠ¡å¼‚å¸¸éƒ½ä¼šè§¦å‘å–æ¶ˆç»„å†…å…¶å®ƒä»»åŠ¡å¹¶åœ¨é€€å‡ºæ—¶èšåˆå¼‚å¸¸ï¼ˆExceptionGroupï¼‰ã€‚asyncio åŸç”Ÿè¡Œä¸ºåœ¨æ—©æœŸç‰ˆæœ¬ä¸Šä¸ Trio ä¸åŒï¼Œéœ€åœ¨é—¨é¢å±‚ç»Ÿä¸€è¯­ä¹‰ã€‚ å–æ¶ˆä½œç”¨åŸŸæ˜¯ä¸€ç§ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œå®ƒå®šä¹‰äº†ä¸€æ®µå¯ä½œä¸ºä¸€ä¸ªå•å…ƒå–æ¶ˆçš„ä»£ç åŒºåŸŸã€‚å–æ¶ˆä½œç”¨åŸŸå¯ä»¥åµŒå¥—ï¼Œå–æ¶ˆå¤–å±‚ä½œç”¨åŸŸä¼šè‡ªåŠ¨å–æ¶ˆæ‰€æœ‰å†…å±‚ä½œç”¨åŸŸã€‚ å…³é”®ä»£ç  12345678910111213141516171819202122232425262728293031323334353637class CancelScope(BaseCancelScope): def __init__(self, deadline: float = math.inf, shield: bool = False): self._deadline = deadline self._shield = shield # æ¯”è¾ƒå…¸å‹çš„æ ‘å½¢ç»“æ„ self._parent_scope: CancelScope | None = None self._child_scopes: set[CancelScope] = set() ... # å›´ç»•æ ‘å½¢ç»“æ„çš„æ“ä½œ def __enter__(self) -&gt; CancelScope: # æŠŠå½“å‰ä»»åŠ¡ä»åŸçˆ¶èŠ‚ç‚¹æ‘˜ä¸‹ï¼ŒæŒ‚åˆ°æ–°çš„ CancelScope èŠ‚ç‚¹ä¸‹ â†’ æ ‘å‘ä¸‹é•¿å‡ºä¸€å±‚ã€‚ ... def __exit__( self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, ) -&gt; bool: # æŠŠå½“å‰ä»»åŠ¡ä»å½“å‰èŠ‚ç‚¹æ‘˜ä¸‹ï¼Œé‡æ–°æŒ‚å›åŸçˆ¶èŠ‚ç‚¹ â†’ æ ‘å‘ä¸Šåˆå¹¶ä¸€å±‚ã€‚ ... class TaskState: &quot;&quot;&quot; Encapsulates auxiliary task information that cannot be added to the Task instance itself because there are no guarantees about its implementation. &quot;&quot;&quot; __slots__ = &quot;parent_id&quot;, &quot;cancel_scope&quot;, &quot;__weakref__&quot; def __init__(self, parent_id: int | None, cancel_scope: CancelScope | None): self.parent_id = parent_id self.cancel_scope = cancel_scope_task_states: WeakKeyDictionary[asyncio.Task, TaskState] = WeakKeyDictionary() æ€»ç»“ï¼š æ–‡ä»¶ç»´æŠ¤ _task_statesï¼ˆä»»åŠ¡ â†’ TaskStateï¼‰ï¼Œæ¯ä¸ª TaskState ä¿ç•™è¯¥ä»»åŠ¡çš„ cancel_scope ç­‰ä¿¡æ¯ï¼›TaskGroup._spawn() åœ¨åˆ›å»º task æ—¶æŠŠå®ƒæ’å…¥ _task_statesï¼Œå¹¶è®©å­ä»»åŠ¡ç»§æ‰¿çˆ¶ cancel scopeã€‚ å­ä»»åŠ¡å®Œæˆå›è°ƒ task_doneï¼šå¦‚æœå­ä»»åŠ¡æŠ›å‡ºå¼‚å¸¸ï¼ˆé CancelledErrorï¼‰ï¼Œä¼šæŠŠå¼‚å¸¸åŠ å…¥è¯¥ TaskGroup çš„ _exceptions åˆ—è¡¨ï¼Œå¹¶è§¦å‘ self.cancel_scope.cancel() æ¥å–æ¶ˆå…¶å®ƒå­ä»»åŠ¡ï¼›æœ€ç»ˆåœ¨ TaskGroup é€€å‡ºæ—¶æŠŠå¤šä¸ªå¼‚å¸¸èšåˆä¸º BaseExceptionGroup æˆ–é‡æ–°æŠ›å•ä¸ªå¼‚å¸¸ã€‚è¿™æ ·å®ç°äº†â€œå¤±è´¥å³å–æ¶ˆ + å¼‚å¸¸èšåˆâ€ã€‚ WorkerThread123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384WorkerThread(Thread): MAX_IDLE_TIME = 10 # seconds def __init__( self, root_task: asyncio.Task, workers: set[WorkerThread], idle_workers: deque[WorkerThread], ): super().__init__(name=&quot;AnyIO worker thread&quot;) self.root_task = root_task # ç»‘å®šçš„ asyncio ä¸»å¾ªç¯ï¼ˆç”¨å®ƒæŠŠç»“æœé€å›ï¼‰ã€‚ self.workers = workers self.idle_workers = idle_workers # å…¨å±€åŒç«¯é˜Ÿåˆ—ï¼Œçº¿ç¨‹ç©ºé—²æ—¶æŠŠè‡ªå·±å¡å›å»ä»¥ä¾¿å¤ç”¨ã€‚ self.loop = root_task._loop self.queue: Queue[ tuple[Context, Callable, tuple, asyncio.Future, CancelScope] | None ] = Queue(2) self.idle_since = AsyncIOBackend.current_time() # è®°å½•æœ€è¿‘ä¸€æ¬¡å˜æˆç©ºé—²çš„æ—¶é—´æˆ³ï¼Œç”¨äºè¿‡æœŸæ·˜æ±°ã€‚ self.stopping = False def _report_result( self, future: asyncio.Future, result: Any, exc: BaseException | None ) -&gt; None: # æ›´æ–°ç©ºé—²æ—¶é—´ self.idle_since = AsyncIOBackend.current_time() if not self.stopping: # æŠŠè‡ªå·±æ”¾å›å¤ç”¨é˜Ÿåˆ— self.idle_workers.append(self) if not future.cancelled(): if exc is not None: if isinstance(exc, StopIteration): new_exc = RuntimeError(&quot;coroutine raised StopIteration&quot;) new_exc.__cause__ = exc exc = new_exc future.set_exception(exc) else: future.set_result(result) def run(self) -&gt; None: # æŠŠå½“å‰äº‹ä»¶å¾ªç¯å’Œåç«¯ç±»æ³¨å†Œåˆ°çº¿ç¨‹ with claim_worker_thread(AsyncIOBackend, self.loop): while True: # é˜»å¡ç­‰å¾…ä»»åŠ¡æˆ– None(å…³é—­) item = self.queue.get() if item is None: # Shutdown command received return context, func, args, future, cancel_scope = item if not future.cancelled(): # å·²ç»è¢«ä¸Šå±‚å–æ¶ˆ â†’ ç›´æ¥ä¸¢ result = None exception: BaseException | None = None threadlocals.current_cancel_scope = cancel_scope try: # åœ¨â€œä¸´æ—¶ä¸Šä¸‹æ–‡â€é‡Œè·‘ä¸€æ®µä»£ç ï¼Œè·‘å®Œè‡ªåŠ¨æ¢å¤æ—§ä¸Šä¸‹æ–‡ã€‚ result = context.run(func, *args) except BaseException as exc: exception = exc finally: del threadlocals.current_cancel_scope # æŠŠç»“æœ/å¼‚å¸¸é€å›äº‹ä»¶å¾ªç¯ if not self.loop.is_closed(): self.loop.call_soon_threadsafe( self._report_result, future, result, exception ) del result, exception self.queue.task_done() del item, context, func, args, future, cancel_scope def stop(self, f: asyncio.Task | None = None) -&gt; None: self.stopping = True self.queue.put_nowait(None) self.workers.discard(self) try: self.idle_workers.remove(self) except ValueError: pass AnyIO æä¾›äº†ä¸¤ä¸ªæ··åˆç±»æ¥ç®€åŒ–ä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„å®ç°ï¼š ContextManagerMixin- ç”¨äºå®ç°åŒæ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ AsyncContextManagerMixin- ç”¨äºå®ç°å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨ è¿™äº›æ··åˆå™¨æä¾›äº†ä¸€ç§åŸºäºç”Ÿæˆå™¨çš„æ–¹æ³•æ¥å®ç°ä¸Šä¸‹æ–‡ç®¡ç†å™¨ï¼Œç±»ä¼¼äº Python çš„å†…ç½®@contextmanagerå’Œ@asynccontextmanagerè£…é¥°å™¨ backend123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140class AsyncIOBackend(AsyncBackend): @classmethod def run( cls, func: Callable[..., Awaitable[T_Retval]], args: tuple, kwargs: dict[str, Any], options: dict[str, Any], ) -&gt; T_Retval: &quot;&quot;&quot; ç­‰ä»·äº asyncio.run()ï¼Œä½†æ”¯æŒ uvloopã€debug ç­‰é€‰é¡¹ã€‚ å†…éƒ¨ç”¨æ ‡å‡†åº“ 3.11+ çš„ asyncio.Runnerã€‚ &quot;&quot;&quot; @wraps(func) async def wrapper() -&gt; T_Retval: task = cast(asyncio.Task, current_task()) task.set_name(get_callable_name(func)) # è®©æ ˆè¿½è¸ªæ›´å¥½çœ‹ _task_states[task] = TaskState(None, None) # åˆå§‹åŒ–ä»»åŠ¡çŠ¶æ€ try: return await func(*args, **kwargs) finally: del _task_states[task] # æ¸…ç†å¼±å¼•ç”¨ï¼Œé¿å…æ³„æ¼ debug = options.get(&quot;debug&quot;) loop_factory = options.get(&quot;loop_factory&quot;) if loop_factory is None and options.get(&quot;use_uvloop&quot;, False): import uvloop loop_factory = uvloop.new_event_loop # ä½¿ç”¨ Runner å®ç°å¤š run å¤ç”¨ with Runner(debug=debug, loop_factory=loop_factory) as runner: return runner.run(wrapper()) # ---------- å–æ¶ˆç›¸å…³å·¥å…· ---------- @classmethod async def checkpoint(cls) -&gt; None: &quot;&quot;&quot;å¼ºåˆ¶ä¸€æ¬¡äº‹ä»¶å¾ªç¯è¿­ä»£ï¼Œè®©å‡ºä»»åŠ¡è°ƒåº¦ï¼Œç›¸å½“äº trio.lowlevel.checkpoint() &quot;&quot;&quot; await sleep(0) @classmethod async def checkpoint_if_cancelled(cls) -&gt; None: &quot;&quot;&quot; å¦‚æœå½“å‰ä»»åŠ¡æˆ–å…¶ä»»ä¸€çˆ¶ CancelScope å·²è¢«å–æ¶ˆï¼Œ ç«‹å³æŠ›å‡º CancelledErrorï¼›å¦åˆ™ä»€ä¹ˆéƒ½ä¸åšã€‚ &quot;&quot;&quot; task = current_task() if task is None: return try: cancel_scope = _task_states[task].cancel_scope except KeyError: return while cancel_scope: if cancel_scope.cancel_called: await sleep(0) # è§¦å‘çœŸæ­£çš„ asyncio.CancelledError elif cancel_scope.shield: # è¢«å±è”½ï¼Œåœæ­¢å‘ä¸Šæ£€æŸ¥ break else: cancel_scope = cancel_scope._parent_scope @classmethod async def cancel_shielded_checkpoint(cls) -&gt; None: &quot;&quot;&quot;åœ¨å±è”½å–æ¶ˆçš„çŠ¶æ€ä¸‹åšä¸€æ¬¡ checkpointï¼ˆè®©å‡ºè°ƒåº¦ä½†ä¸å“åº”å–æ¶ˆï¼‰&quot;&quot;&quot; with CancelScope(shield=True): await sleep(0) # ---------- å–æ¶ˆä½œç”¨åŸŸ ---------- @classmethod def create_cancel_scope( cls, *, deadline: float = math.inf, shield: bool = False ) -&gt; CancelScope: return CancelScope(deadline=deadline, shield=shield) # ---------- çº¿ç¨‹æ±  ---------- @classmethod async def run_sync_in_worker_thread( cls, func: Callable[..., T_Retval], args: tuple, *, abandon_on_cancel: bool = False, limiter: abc.CapacityLimiter | None = None, ) -&gt; T_Retval: &quot;&quot;&quot; æŠŠåŒæ­¥å‡½æ•°ä¸¢åˆ°å·¥ä½œçº¿ç¨‹æ‰§è¡Œï¼Œè¿”å› awaitable çš„ç»“æœã€‚ æ”¯æŒå®¹é‡é™åˆ¶å™¨ã€å–æ¶ˆæ—¶æ˜¯å¦æ”¾å¼ƒçº¿ç¨‹ã€‚ &quot;&quot;&quot; await cls.checkpoint() # è®©è°ƒåº¦å™¨å…ˆè·‘ä¸€æ¬¡ï¼Œé¿å…æ­»é” # æƒ°æ€§åˆå§‹åŒ–çº¿ç¨‹æ± ç›¸å…³å…¨å±€å˜é‡ try: idle_workers = _threadpool_idle_workers.get() workers = _threadpool_workers.get() except LookupError: idle_workers = deque() workers = set() _threadpool_idle_workers.set(idle_workers) _threadpool_workers.set(workers) async with limiter or cls.current_default_thread_limiter(): # è‹¥ abandon_on_cancel=Falseï¼Œåˆ™å–æ¶ˆæ—¶**ä¸**æ€çº¿ç¨‹ with CancelScope(shield=not abandon_on_cancel) as scope: future = asyncio.Future[T_Retval]() root_task = find_root_task() # å¤ç”¨æˆ–æ–°å»º WorkerThread if not idle_workers: worker = WorkerThread(root_task, workers, idle_workers) worker.start() workers.add(worker) root_task.add_done_callback(worker.stop) else: worker = idle_workers.pop() # æ¸…ç†è¿‡æœŸç©ºé—²çº¿ç¨‹â€¦â€¦ ... # æ‹·è´ä¸Šä¸‹æ–‡ context = copy_context() context.run(sniffio.current_async_library_cvar.set, None) worker.queue.put_nowait((context, func, args, future, scope)) return await future # ---------- å…¶ä»–å·¥å‚æ–¹æ³• ---------- @classmethod def create_task_group(cls) -&gt; abc.TaskGroup: ... @classmethod def create_lock(cls, *, fast_acquire: bool) -&gt; abc.Lock: ... @classmethod def create_semaphore(cls, initial_value: int, *, max_value=None, fast_acquire=False) -&gt; abc.Semaphore: ... @classmethod def create_event(cls) -&gt; abc.Event: ... @classmethod def connect_tcp(cls, host: str, port: int, local_address=None) -&gt; abc.SocketStream: ... @classmethod def current_time(cls) -&gt; float: ... ... ä¸Šä¸‹æ–‡å˜é‡ï¼ˆcontextvarsï¼‰ä»å¼‚æ­¥ä»»åŠ¡ä¼ æ’­åˆ°å·¥ä½œçº¿ç¨‹ã€‚è¿™æ„å‘³ç€åœ¨å¼‚æ­¥ä»»åŠ¡ä¸­è®¾ç½®çš„ä»»ä½•ä¸Šä¸‹æ–‡å˜é‡éƒ½å°†åœ¨å·¥ä½œçº¿ç¨‹ä¸­å¯ç”¨ï¼Œä½†æ˜¯å¯¹å·¥ä½œçº¿ç¨‹ä¸­çš„ä¸Šä¸‹æ–‡å˜é‡æ‰€åšçš„ä»»ä½•æ›´æ”¹éƒ½ä¸ä¼šä¼ æ’­å›å¼‚æ­¥ä»»åŠ¡ï¼š 12345678910111213import contextvarscv = contextvars.ContextVar(&#x27;demo&#x27;, default=&#x27;global&#x27;)def show(): print(cv.get())# ä¸´æ—¶æ”¹å†™ctx = contextvars.copy_context()ctx.run(lambda: [cv.set(&#x27;local&#x27;), show()]) # è¾“å‡º local# åŸä¸Šä¸‹æ–‡ä¸å—å½±å“show() # è¾“å‡º global _tiro.pyå¯¹äº tiro çš„æ”¹é€ æ¯”è¾ƒå°‘ï¼ŒåŸºæœ¬æ˜¯ä½¿ç”¨ tiro çš„åŸæœ¬åŠŸèƒ½ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class CancelScope(BaseCancelScope): def __new__( cls, original: trio.CancelScope | None = None, **kwargs: object ) -&gt; CancelScope: return object.__new__(cls) def __init__(self, original: trio.CancelScope | None = None, **kwargs: Any) -&gt; None: self.__original = original or trio.CancelScope(**kwargs) def __enter__(self) -&gt; CancelScope: self.__original.__enter__() return self def __exit__( self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, ) -&gt; bool: return self.__original.__exit__(exc_type, exc_val, exc_tb) def cancel(self) -&gt; None: self.__original.cancel() @property def deadline(self) -&gt; float: return self.__original.deadline @deadline.setter def deadline(self, value: float) -&gt; None: self.__original.deadline = value @property def cancel_called(self) -&gt; bool: return self.__original.cancel_called @property def cancelled_caught(self) -&gt; bool: return self.__original.cancelled_caught @property def shield(self) -&gt; bool: return self.__original.shield @shield.setter def shield(self, value: bool) -&gt; None: self.__original.shield = valueclass TaskGroup(abc.TaskGroup): def __init__(self) -&gt; None: self._active = False self._nursery_manager = trio.open_nursery(strict_exception_groups=True) self.cancel_scope = None # type: ignore[assignment] async def __aenter__(self) -&gt; TaskGroup: self._active = True self._nursery = await self._nursery_manager.__aenter__() self.cancel_scope = CancelScope(self._nursery.cancel_scope) return self async def __aexit__( self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None, ) -&gt; bool: try: # trio.Nursery.__exit__ returns bool; .open_nursery has wrong type return await self._nursery_manager.__aexit__(exc_type, exc_val, exc_tb) # type: ignore[return-value] except BaseExceptionGroup as exc: if not exc.split(trio.Cancelled)[1]: raise trio.Cancelled._create() from exc raise finally: del exc_val, exc_tb self._active = False def start_soon( self, func: Callable[[Unpack[PosArgsT]], Awaitable[Any]], *args: Unpack[PosArgsT], name: object = None, ) -&gt; None: if not self._active: raise RuntimeError( &quot;This task group is not active; no new tasks can be started.&quot; ) self._nursery.start_soon(func, *args, name=name) async def start( self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None ) -&gt; Any: if not self._active: raise RuntimeError( &quot;This task group is not active; no new tasks can be started.&quot; ) return await self._nursery.start(func, *args, name=name) æ ¸å¿ƒç»„ä»¶ï¼ˆ_coreï¼‰ç”±äºåŸºç¡€ç»„ä»¶å¾ˆå¤šè¿™é‡Œåªåšéƒ¨åˆ†ä»£ç è§£æ åŒæ­¥åŸè¯­AnyIO æä¾›äº†å‡ ä¸ªä¸asyncioå’Œtrioåç«¯å…¼å®¹çš„åŒæ­¥åŸè¯­ï¼š äº‹ä»¶ï¼šå‘ç”ŸæŸäº‹æ—¶åœ¨ä»»åŠ¡ä¹‹é—´å‘å‡ºä¿¡å· é”ï¼šç¡®ä¿å¯¹å…±äº«èµ„æºçš„ç‹¬å è®¿é—® æ¡ä»¶ï¼šå°†é”ä¸ç­‰å¾…æ¡ä»¶æˆç«‹çš„èƒ½åŠ›ç»“åˆèµ·æ¥ ä¿¡å·é‡ï¼šæ§åˆ¶å¯¹æœ‰é™æ•°é‡èµ„æºçš„è®¿é—® CapacityLimiterï¼šé™åˆ¶å¹¶å‘æ“ä½œæ•° ResourceGuardï¼šä¿æŠ¤èµ„æºå…äºå¹¶å‘ä½¿ç”¨ å¯¹äº Tiro, åŒæ­¥åŸè¯­çš„å®ç°åŸºæœ¬è¿˜æ˜¯ç”¨çš„æºåº“çš„åŠŸèƒ½ï¼Œè¿™é‡Œä¸»è¦å¯¹ asyncio åšåˆ†æ LockPSï¼štask = cast(asyncio.Task, current_task()) è¿è¡Œæ—¶å®Œå…¨ç­‰äºç›´æ¥èµ‹å€¼ï¼Œä½†æ˜¯è¿™æ ·å†™å¯ä»¥é¿å… mypy &#x2F; pyright &#x2F; pylance æŠ¥ç©ºæŒ‡é’ˆé”™è¯¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Lock(BaseLock): def __new__(cls, *, fast_acquire: bool = False) -&gt; Lock: return object.__new__(cls) def __init__(self, *, fast_acquire: bool = False) -&gt; None: self._fast_acquire = fast_acquire self._owner_task: asyncio.Task | None = None # è·å–é”çš„ä»»åŠ¡ self._waiters: deque[tuple[asyncio.Task, asyncio.Future]] = deque() # ç­‰å¾…é˜Ÿåˆ— async def acquire(self) -&gt; None: task = cast(asyncio.Task, current_task()) if self._owner_task is None and not self._waiters: await AsyncIOBackend.checkpoint_if_cancelled() self._owner_task = task # è®©ã€Œæ°å¥½æ²¡äººç«äº‰é”ã€æ—¶ çœä¸€æ¬¡å¤šä½™çš„ await asyncio.sleep(0)ï¼Œç›´æ¥æ‹¿åˆ°é”ç»§ç»­è·‘ï¼Œæé«˜æç«¯é«˜é¢‘ä½ç«äº‰åœºæ™¯ä¸‹çš„ååé‡ã€‚ if not self._fast_acquire: try: await AsyncIOBackend.cancel_shielded_checkpoint() except CancelledError: self.release() raise return # é‡å…¥æ£€æŸ¥ if self._owner_task == task: raise RuntimeError(&quot;Attempted to acquire an already held Lock&quot;) # è¿›å…¥æ’é˜Ÿ fut: asyncio.Future[None] = asyncio.Future() item = task, fut self._waiters.append(item) try: # æŒ‚èµ·ç›´åˆ°è¢« release() å”¤é†’ await fut except CancelledError: self._waiters.remove(item) # æç«¯ï¼šåˆšå·§è½®åˆ°å°±è¢«å–æ¶ˆ if self._owner_task is task: self.release() raise self._waiters.remove(item) def acquire_nowait(self) -&gt; None: task = cast(asyncio.Task, current_task()) if self._owner_task is None and not self._waiters: self._owner_task = task return if self._owner_task is task: raise RuntimeError(&quot;Attempted to acquire an already held Lock&quot;) raise WouldBlock def locked(self) -&gt; bool: return self._owner_task is not None def release(self) -&gt; None: if self._owner_task != current_task(): raise RuntimeError(&quot;The current task is not holding this lock&quot;) for task, fut in self._waiters: if not fut.cancelled(): self._owner_task = task fut.set_result(None) return self._owner_task = None def statistics(self) -&gt; LockStatistics: task_info = AsyncIOTaskInfo(self._owner_task) if self._owner_task else None return LockStatistics(self.locked(), task_info, len(self._waiters)) çº¿ç¨‹å’Œè¿›ç¨‹ç®¡ç† anyio.to_thread.run_sync å¯¹äºå— AnyIO ç®¡ç†çš„çº¿ç¨‹ BlockingPortal- å¯¹äºä¸å— AnyIO ç®¡ç†çš„å¤–éƒ¨çº¿ç¨‹ å…ˆçœ‹ä¸¤ä¸ªé”™è¯¯ç¤ºä¾‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import asyncioimport threadingimport anyioasync def async_database_query(): print(&quot;æ‰§è¡Œå¼‚æ­¥æ•°æ®åº“æŸ¥è¯¢&quot;) await anyio.sleep(0.5) return [&quot;æ•°æ®1&quot;, &quot;æ•°æ®2&quot;]def thread_worker(): &quot;&quot;&quot;è¿è¡Œåœ¨çº¿ç¨‹ä¸­çš„å‡½æ•°&quot;&quot;&quot; print(&quot;åœ¨çº¿ç¨‹ä¸­å·¥ä½œ&quot;) # -----------------é”™è¯¯ç¤ºä¾‹------------------- # ä»çº¿ç¨‹è°ƒç”¨å¼‚æ­¥ä»£ç  try: result = anyio.from_thread.run(async_database_query) # è¾“å‡º ERROR: This function can only be run from an AnyIO worker thread print(f&quot;çº¿ç¨‹è·å¾—ç»“æœ: &#123;result&#125;&quot;) except Exception as e: print(f&quot;é”™è¯¯: &#123;e&#125;&quot;) &quot;&quot;&quot; éœ€è¦å°† thread = threading.Thread(target=thread_worker, name=&quot;å·¥ä½œçº¿ç¨‹&quot;) thread.start() æ”¹ä¸º result = await anyio.to_thread.run_sync(thread_worker) &quot;&quot;&quot; # -----------------é”™è¯¯ç¤ºä¾‹------------------- new_loop = asyncio.new_event_loop() asyncio.set_event_loop(new_loop) # å°è¯•è¿è¡Œï¼Œèƒ½æ­£å¸¸å‡ºç»“æœ result = new_loop.run_until_complete(async_database_query()) print(f&quot;ç»“æœ: &#123;result&#125;&quot;) new_loop.close() &quot;&quot;&quot; 1.å¤šä¸ªäº‹ä»¶å¾ªç¯å†²çªï¼šä¸»å¾ªç¯å’Œçº¿ç¨‹ä¸­çš„å¾ªç¯ä¼šå†²çª 2.èµ„æºç«äº‰ï¼šå¤šä¸ªå¾ªç¯å¯èƒ½ç«äº‰ç›¸åŒçš„èµ„æº 3.ä¸å¯é¢„æµ‹çš„è¡Œä¸ºï¼šå¯èƒ½å¯¼è‡´éšæœºå´©æºƒæˆ–æ•°æ®æŸå 4.ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼šasyncio çš„å¾ˆå¤šç»„ä»¶ä¸æ˜¯ä¸ºå¤šå¾ªç¯è®¾è®¡çš„ &quot;&quot;&quot;async def main_async(): &quot;&quot;&quot;ä¸»å¼‚æ­¥å‡½æ•°&quot;&quot;&quot; print(&quot;å¯åŠ¨ä¸»å¼‚æ­¥ä»»åŠ¡&quot;) # å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹ thread = threading.Thread(target=thread_worker, name=&quot;å·¥ä½œçº¿ç¨‹&quot;) thread.start() # åŒæ—¶æ‰§è¡Œå…¶ä»–å¼‚æ­¥å·¥ä½œ await anyio.sleep(1) print(&quot;ä¸»å¼‚æ­¥ä»»åŠ¡å®Œæˆ&quot;) thread.join()if __name__ == &quot;__main__&quot;: anyio.run(main_async) æ­£ç¡®ç¤ºä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import threadingimport anyiofrom anyio.from_thread import BlockingPortalasync def async_database_query(): print(&quot;æ‰§è¡Œå¼‚æ­¥æ•°æ®åº“æŸ¥è¯¢&quot;) await anyio.sleep(0.5) return [&quot;æ•°æ®1&quot;, &quot;æ•°æ®2&quot;]def thread_worker(portal: BlockingPortal): &quot;&quot;&quot;è¿è¡Œåœ¨å¤–éƒ¨çº¿ç¨‹ä¸­çš„å‡½æ•°&quot;&quot;&quot; print(&quot;åœ¨çº¿ç¨‹ä¸­å·¥ä½œ&quot;) # æ­£ç¡®ï¼šä½¿ç”¨BlockingPortalè°ƒç”¨å¼‚æ­¥ä»£ç  try: result = portal.call(async_database_query) print(f&quot;çº¿ç¨‹è·å¾—ç»“æœ: &#123;result&#125;&quot;) except Exception as e: print(f&quot;é”™è¯¯: &#123;e&#125;&quot;)async def main_async(): &quot;&quot;&quot;ä¸»å¼‚æ­¥å‡½æ•°&quot;&quot;&quot; print(&quot;å¯åŠ¨ä¸»å¼‚æ­¥ä»»åŠ¡&quot;) # åˆ›å»ºBlockingPortal async with BlockingPortal() as portal: # å¯åŠ¨å¤–éƒ¨çº¿ç¨‹ï¼ˆç”±threading.Threadåˆ›å»ºï¼‰ thread = threading.Thread( target=thread_worker, args=(portal,), # ä¼ å…¥portal name=&quot;å·¥ä½œçº¿ç¨‹&quot; ) thread.start() # åŒæ—¶æ‰§è¡Œå…¶ä»–å¼‚æ­¥å·¥ä½œ await anyio.sleep(1) print(&quot;ä¸»å¼‚æ­¥ä»»åŠ¡å®Œæˆ&quot;) thread.join()if __name__ == &quot;__main__&quot;: anyio.run(main_async) å¯ä»¥ç®€å•ç†è§£ä¸ºï¼šå¦‚æœé¡¹ç›®ä¸­å·²ç»æœ‰åŒæ­¥çš„å¤šçº¿ç¨‹ä»£ç ï¼Œåº”è¯¥ç”¨ BlockingPortalï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™ anyio.to_thread.run_sync æ›´å¥½ï¼Œæ›´æ–¹ä¾¿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class BlockingPortal: &quot;&quot;&quot;å…è®¸å¤–éƒ¨çº¿ç¨‹åœ¨å¼‚æ­¥äº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œä»£ç çš„å¯¹è±¡ã€‚&quot;&quot;&quot; def __new__(cls) -&gt; BlockingPortal: # å·¥å‚æ–¹æ³•ï¼šæ ¹æ®å½“å‰åç«¯åˆ›å»º BlockingPortal å®ä¾‹ return get_async_backend().create_blocking_portal() def __init__(self) -&gt; None: # ä¿å­˜äº‹ä»¶å¾ªç¯æ‰€åœ¨çš„çº¿ç¨‹ ID self._event_loop_thread_id: int | None = get_ident() # ç”¨äº stop() é€šçŸ¥çš„äº‹ä»¶ self._stop_event = Event() # å†…éƒ¨çš„ TaskGroupï¼Œç”¨äºå¯åŠ¨/ç®¡ç†å¼‚æ­¥ä»»åŠ¡ self._task_group = create_task_group() # åç«¯ç‰¹å®šçš„ CancelledError ç±» self._cancelled_exc_class = get_cancelled_exc_class() async def __aenter__(self) -&gt; BlockingPortal: # è¿›å…¥ async with æ—¶ï¼Œå¯åŠ¨ TaskGroup await self._task_group.__aenter__() return self async def __aexit__(...): # é€€å‡º async with æ—¶ï¼Œè°ƒç”¨ stop å¹¶é€€å‡º TaskGroup await self.stop() return await self._task_group.__aexit__(...) def _check_running(self) -&gt; None: # ç¡®è®¤ portal æ­£å¸¸è¿è¡Œï¼Œä¸”ä¸æ˜¯åœ¨äº‹ä»¶å¾ªç¯çº¿ç¨‹å†…è°ƒç”¨ if self._event_loop_thread_id is None: raise RuntimeError(&quot;This portal is not running&quot;) if self._event_loop_thread_id == get_ident(): raise RuntimeError(&quot;This method cannot be called from the event loop thread&quot;) async def sleep_until_stopped(self) -&gt; None: &quot;&quot;&quot;é˜»å¡ç­‰å¾…ï¼Œç›´åˆ° stop() è¢«è°ƒç”¨ã€‚&quot;&quot;&quot; await self._stop_event.wait() async def stop(self, cancel_remaining: bool = False) -&gt; None: &quot;&quot;&quot; åœæ­¢ portalï¼š - ä¸å†æ¥å—æ–°ä»»åŠ¡ - è§£é™¤ sleep_until_stopped - å¯é€‰ï¼šå–æ¶ˆæ‰€æœ‰å‰©ä½™ä»»åŠ¡ &quot;&quot;&quot; self._event_loop_thread_id = None self._stop_event.set() if cancel_remaining: self._task_group.cancel_scope.cancel() async def _call_func(...): &quot;&quot;&quot; ç”± _spawn_task_from_thread è°ƒç”¨ï¼š - æ‰§è¡Œç›®æ ‡å‡½æ•° - å¦‚æœè¿”å› awaitableï¼Œåˆ™åœ¨ CancelScope ä¸­ await - æ­£ç¡®å¤„ç†å¼‚å¸¸ã€å–æ¶ˆï¼Œå¹¶å†™å› Future &quot;&quot;&quot; def callback(f: Future): ... try: retval_or_awaitable = func(*args, **kwargs) if isawaitable(retval_or_awaitable): with CancelScope() as scope: ... retval = await retval_or_awaitable else: retval = retval_or_awaitable except self._cancelled_exc_class: future.cancel() future.set_running_or_notify_cancel() except BaseException as exc: if not future.cancelled(): future.set_exception(exc) if not isinstance(exc, Exception): raise else: if not future.cancelled(): future.set_result(retval) finally: scope = None def _spawn_task_from_thread(...): &quot;&quot;&quot; æŠ½è±¡æ–¹æ³•ï¼šåœ¨äº‹ä»¶å¾ªç¯çº¿ç¨‹ä¸­å¯åŠ¨ä»»åŠ¡ã€‚ - ç”±å…·ä½“åç«¯å®ç° - ç¡®ä¿ä»»åŠ¡å®Œæˆæ—¶ï¼Œèƒ½æ­£ç¡®è§£æ Future &quot;&quot;&quot; raise NotImplementedError def call(self, func, *args) -&gt; T_Retval: &quot;&quot;&quot; åœ¨äº‹ä»¶å¾ªç¯ä¸­åŒæ­¥æ‰§è¡Œå‡½æ•°ã€‚ - å¦‚æœè¿”å› coroutineï¼Œä¼šç­‰å¾…å®Œæˆ - å¯¹å¤–è¡¨ç°ä¸ºé˜»å¡è°ƒç”¨ &quot;&quot;&quot; return cast(T_Retval, self.start_task_soon(func, *args).result()) def start_task_soon(...): &quot;&quot;&quot; å¼‚æ­¥åœ°åœ¨ TaskGroup ä¸­å¯åŠ¨ä»»åŠ¡ï¼ˆä»å¤–éƒ¨çº¿ç¨‹å‘èµ·ï¼‰ã€‚ - è¿”å› concurrent.futures.Future - å…è®¸è°ƒç”¨æ–¹å–æ¶ˆ Future æ¥å–æ¶ˆä»»åŠ¡ &quot;&quot;&quot; self._check_running() f: Future = Future() self._spawn_task_from_thread(func, args, &#123;&#125;, name, f) return f def start_task(...): &quot;&quot;&quot; ç±»ä¼¼ TaskGroup.startï¼šåœ¨å¯åŠ¨ä»»åŠ¡æ—¶ï¼Œç­‰å¾…å…¶è°ƒç”¨ task_status.started()ã€‚ è¿”å› (Future, task_status_value)ã€‚ &quot;&quot;&quot; def task_done(future: Future): ... self._check_running() task_status_future: Future = Future() task_status = _BlockingPortalTaskStatus(task_status_future) f: Future = Future() f.add_done_callback(task_done) self._spawn_task_from_thread(func, args, &#123;&quot;task_status&quot;: task_status&#125;, name, f) return f, task_status_future.result() def wrap_async_context_manager(self, cm): &quot;&quot;&quot; å°† async context manager åŒ…è£…ä¸º sync context managerï¼š - åœ¨å†…éƒ¨å¯åŠ¨ä»»åŠ¡ï¼Œè°ƒç”¨ __aenter__ / __aexit__ - æ–¹ä¾¿åœ¨åŒæ­¥ä»£ç ä¸­ä½¿ç”¨ async ä¸Šä¸‹æ–‡ &quot;&quot;&quot; return _BlockingAsyncContextManager(cm, self) ç»“è¯­ä¸¤å¹´å‰é˜…è¯» uvicorn çš„æºç æ—¶ä¹Ÿæ˜¯ç”¨äº†AIï¼Œä½†æ˜¯æ•ˆæœä¸å°½äººæ„ã€‚çŸ­çŸ­ä¸€å¹´ï¼ŒAI çš„è¿›æ­¥å·²ç»èƒ½è®©æ•´ä¸ªé¡¹ç›®å…¨éƒ¨æŠ•å…¥å…¶ä¸­ï¼Œå„ä¸ªä»£ç å…³é”®ç‚¹å…¨é¢è§£æï¼Œç”šè‡³è¿˜èƒ½åšå‡ºå›¾è¡¨è®©äººæ›´å®¹æ˜“ç†è§£ã€‚ æœ¬æ–‡å«æœ‰å¤§é‡ AI ç”Ÿæˆçš„å†…å®¹ å½“å‰è§£æ anyio ç‰ˆæœ¬ 4.10.0 æ¨èé˜…è¯»DeepWiki åŸæ–‡","tags":["python","uvicron"]},{"title":"python json åº“æ€§èƒ½å¯¹æ¯”","path":"/2024/10/07/python-json-åº“æ€§èƒ½å¯¹æ¯”/","content":"ä¸»è¦æŒ‘é€‰äº†ä¸‰ä¸ªåº“è¿›è¡Œå¯¹æ¯”: json, orjson, simdjson orjson å¼€æºç¤¾åŒºï¼šhttps://github.com/ijl/orjson orjson æ˜¯ä¸€ä¸ªå¿«é€Ÿã€æ­£ç¡®çš„ Python JSON åº“ã€‚å®ƒ è¢«è¯„ä¸ºæœ€å¿«çš„ JSON Python åº“ï¼Œå¹¶ä¸”æ¯”æ ‡å‡† json åº“æˆ–å…¶ä»–ç¬¬ä¸‰æ–¹åº“æ›´æ­£ç¡®ã€‚å®ƒæœ¬æœºåºåˆ—åŒ– dataclassã€ datetimeã€ numpyå’Œ UUIDå®ä¾‹ã€‚ ä¸å…¶ä»–Python JSONåº“ç›¸æ¯”ï¼Œå®ƒçš„ç‰¹ç‚¹å’Œç¼ºç‚¹ï¼š åºåˆ—åŒ–dataclasså®ä¾‹çš„é€Ÿåº¦æ˜¯å…¶ä»–åº“çš„ 40-50 å€ å°†datetimeã€dateã€ å’Œtimeå®ä¾‹åºåˆ—åŒ–ä¸º RFC 3339 æ ¼å¼ï¼Œä¾‹å¦‚â€œ1970-01-01T00:00:00+00:00â€ åºåˆ—åŒ–numpy.ndarrayå®ä¾‹çš„é€Ÿåº¦æ˜¯å…¶ä»–åº“çš„ 4-12 å€ï¼Œå†…å­˜ä½¿ç”¨é‡æ˜¯å…¶ä»–åº“çš„ 0.3 å€ æ¼‚äº®çš„æ‰“å°é€Ÿåº¦æ˜¯æ ‡å‡†åº“çš„ 10 åˆ° 20 å€ åºåˆ—åŒ–ä¸ºbytesè€Œä¸æ˜¯strï¼Œå³ä¸æ˜¯ç›´æ¥æ›¿æ¢ åºåˆ—åŒ–æ—¶strä¸å°† unicode è½¬ä¹‰ä¸º ASCIIï¼Œä¾‹å¦‚â€œå¥½â€è€Œä¸æ˜¯â€œ\\u597dâ€ åºåˆ—åŒ–floaté€Ÿåº¦æ˜¯å…¶ä»–åº“çš„ 10 å€ï¼Œååºåˆ—åŒ–é€Ÿåº¦æ˜¯å…¶ä»–åº“çš„ä¸¤å€ åŸç”Ÿåºåˆ—åŒ–strã€intã€listå’Œ çš„å­ç±»dictï¼Œéœ€è¦defaultæŒ‡å®šå¦‚ä½•åºåˆ—åŒ–å…¶ä»–ç±» defaultä½¿ç”¨é’©å­åºåˆ—åŒ–ä»»æ„ç±»å‹ å…·æœ‰ä¸¥æ ¼çš„UTF-8ä¸€è‡´æ€§ï¼Œæ¯”æ ‡å‡†åº“æ›´æ­£ç¡® å…·æœ‰ä¸¥æ ¼çš„ JSON ä¸€è‡´æ€§ï¼Œä¸æ”¯æŒ Nan&#x2F;Infinity&#x2F;-Infinity å…·æœ‰å¯¹ 53 ä½æ•´æ•°ä¸¥æ ¼éµå¾ª JSON çš„é€‰é¡¹ï¼Œé»˜è®¤æ”¯æŒ 64 ä½ ä¸æä¾›è¯»å–&#x2F;å†™å…¥ç±»æ–‡ä»¶å¯¹è±¡çš„load()åŠŸèƒ½dump() simdjson å¼€æºç¤¾åŒºï¼šhttps://github.com/simdjson/simdjson JSON åœ¨äº’è”ç½‘ä¸Šéšå¤„å¯è§ã€‚æœåŠ¡å™¨èŠ±è´¹â€œå¤§é‡â€æ—¶é—´æ¥è§£æå®ƒã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§æ–°çš„æ–¹æ³•ã€‚simdjson åº“ä½¿ç”¨å¸¸ç”¨çš„ SIMD æŒ‡ä»¤å’Œå¾®å¹¶è¡Œç®—æ³•ï¼Œè§£æ JSON çš„é€Ÿåº¦æ¯” RapidJSON å¿« 4 å€ï¼Œæ¯”ç°ä»£ C++ çš„ JSON å¿« 25 å€ã€‚ å¿«é€Ÿï¼šæ¯”å¸¸ç”¨çš„ç”Ÿäº§çº§ JSON è§£æå™¨å¿« 4 å€ä»¥ä¸Šã€‚ ç ´çºªå½•çš„åŠŸèƒ½ï¼šä»¥ 6 GB&#x2F;s çš„é€Ÿåº¦å‹ç¼© JSONï¼Œä»¥ 13 GB&#x2F;s çš„é€Ÿåº¦éªŒè¯ UTF-8ï¼Œä»¥ 3.5 GB&#x2F;s çš„é€Ÿåº¦éªŒè¯ NDJSONã€‚ ç®€å•ï¼šä¸€æµã€æ˜“äºä½¿ç”¨ä¸”è¯¦ç»†è®°å½•çš„ APIã€‚ ä¸¥æ ¼ï¼šå®Œæ•´çš„ JSON å’Œ UTF-8 éªŒè¯ï¼Œæ— æŸè§£æã€‚æ€§èƒ½æ¯«ä¸å¦¥åã€‚ è‡ªåŠ¨ï¼šåœ¨è¿è¡Œæ—¶é€‰æ‹©é€‚åˆ CPU çš„è§£æå™¨ã€‚æ— éœ€é…ç½®ã€‚ å¯é ï¼šä»å†…å­˜åˆ†é…åˆ°é”™è¯¯å¤„ç†ï¼Œsimdjson çš„è®¾è®¡é¿å…äº†æ„å¤–ã€‚ æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import jsonimport orjsonimport timeimport simdjsonimport matplotlib.pyplot as plttest_data = &#123; &quot;key1&quot;: &quot;value1&quot;,çœç•¥.. &quot;key100&quot;: &quot;value100&quot;&#125;test_data_str = json.dumps(test_data)def average_every_n(data, n): averaged_data = [] for i in range(0, len(data), n): chunk = data[i:i + n] averaged_data.append(sum(chunk) / len(chunk)) return averaged_datadef json_t(): times = [] for i in range(1, 10001): start_time = time.time() json.dumps(test_data) end_time = time.time() times.append(end_time - start_time) if i % 1000 == 0: averaged_data = average_every_n(times, 1000) yield i // 1000, averaged_data[-1]def orjson_t(): times = [] for i in range(1, 10001): start_time = time.time() orjson.dumps(test_data).decode(&#x27;utf-8&#x27;) end_time = time.time() times.append(end_time - start_time) if i % 1000 == 0: averaged_data = average_every_n(times, 1000) yield i // 1000, averaged_data[-1]def simdjson_t(): times = [] for i in range(1, 10001): start_time = time.time() simdjson.dumps(test_data) end_time = time.time() times.append(end_time - start_time) if i % 1000 == 0: averaged_data = average_every_n(times, 1000) yield i // 1000, averaged_data[-1]if __name__ == &#x27;__main__&#x27;: json_data = list(json_t()) orjson_data = list(orjson_t()) simdjson_data = list(simdjson_t()) # ç»˜åˆ¶å¯¹æ¯”å›¾ plt.plot(*zip(*json_data), label=&#x27;json&#x27;) plt.plot(*zip(*orjson_data), label=&#x27;orjson&#x27;) plt.plot(*zip(*simdjson_data), label=&#x27;simdjson&#x27;) plt.xlabel(&#x27;Iteration (x1000)&#x27;) plt.ylabel(&#x27;Average Time (seconds)&#x27;) plt.legend() plt.title(&#x27;JSON Serialization Performance Comparison&#x27;) plt.show() æµ‹è¯•ç»“æœæ³¨æ„ï¼šç”±äº orjson æ˜¯å°†å¯¹è±¡åºåˆ—åŒ–ä¸ºbytesè€Œä¸æ˜¯strï¼Œå³ä¸æ˜¯ç›´æ¥æ›¿æ¢ï¼Œæ‰€ä»¥åŠ ä¸Š decode(&#39;utf-8&#39;) å°†å…¶è½¬æ¢æˆå­—ç¬¦ä¸² json dumps çš„æ€§èƒ½å¯¹æ¯” json loads çš„æ–°èƒ½å¯¹æ¯” å¯è§ orjson çš„æ€§èƒ½æ˜¯è¿œè¶… python çš„å†…ç½®åº“å’Œ simdjson åº“çš„","tags":["python"]},{"title":"uvicorn-æºç æµ…è¯»","path":"/2024/10/07/uvicorn-æºç æµ…è¯»/","content":"å‰è®°Uvicornæ˜¯ä¸€ä¸ªåŸºäºuvloopå’Œhttptoolsçš„ASGIæœåŠ¡å™¨, æ€§èƒ½æ¯”è¾ƒå¼ºåŠ²ï¼Œ é€šè¿‡å®ƒå¯ä»¥ä¸ä½¿ç”¨ASGIè§„èŒƒçš„Pythonåº”ç”¨ç¨‹åºè¿›è¡Œäº¤äº’ã€‚ASGIä¸WSGIå¾ˆåƒï¼Œ åªä¸è¿‡ASGIåŸç”Ÿæ”¯æŒHTTP2.0å’ŒWebSocketï¼Œ åŒæ—¶æ›´å¤šçš„æ˜¯æ”¯æŒPythonçš„Asyncioç”Ÿæ€çš„WEBåº”ç”¨ç¨‹åºã€‚é€šè¿‡äº†è§£Uvicronï¼Œèƒ½çŸ¥é“ä¸€ä¸ªç¨³å®šçš„WebæœåŠ¡å™¨çš„å·¥ä½œæ–¹å¼ä»¥åŠèƒ½æ›´å¥½çš„å»äº†è§£å…¶ä»–åŸºäºASGIçš„WEBåº”ç”¨ç¨‹åº çŸ¥è¯†ç‚¹ 1uvloop æ˜¯ä¸€ä¸ªç”¨ Cython ç¼–å†™çš„ asyncio äº‹ä»¶å¾ªç¯çš„å¿«é€Ÿæ›¿ä»£å“ï¼Œå®ƒåŸºäº libuvï¼Œè¿™æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½çš„è·¨å¹³å°å¼‚æ­¥ I&#x2F;O åº“ã€‚uvloop è¢«è®¾è®¡ä¸ºå¯ä»¥æ— ç¼æ›¿æ¢ Python æ ‡å‡†åº“ asyncio ä¸­çš„é»˜è®¤äº‹ä»¶å¾ªç¯ï¼Œä»è€Œæé«˜å¼‚æ­¥ç¼–ç¨‹çš„æ€§èƒ½ã€‚å®ƒè‡³å°‘æ¯” Node.jsã€gevent ä»¥åŠå…¶ä»– Python å¼‚æ­¥æ¡†æ¶è¦å¿«ä¸¤å€ï¼Œå…¶æ€§èƒ½æ¥è¿‘ Go ç¨‹åºã€‚ å¼€æºä»“åº“ï¼šhttps://github.com/MagicStack/uvloop ä½¿ç”¨æ–¹æ³• 12345678pip install uvloopimport asyncioimport uvloopasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())# ç¼–å†™asyncioçš„ä»£ç ï¼Œä¸ä¹‹å‰å†™çš„ä»£ç ä¸€è‡´ã€‚# å†…éƒ¨çš„äº‹ä»¶å¾ªç¯è‡ªåŠ¨åŒ–ä¼šå˜ä¸ºuvloopasyncio.run(...) åœ¨ uvicorn ä¸­çš„ä½¿ç”¨ 1234567891011121314151617181920uvicorn/loops/auto.pydef auto_loop_setup(use_subprocess: bool = False) -&gt; None: try: import uvloop # noqa except ImportError: # pragma: no cover from uvicorn.loops.asyncio import asyncio_setup as loop_setup loop_setup(use_subprocess=use_subprocess) else: # pragma: no cover from uvicorn.loops.uvloop import uvloop_setup uvloop_setup(use_subprocess=use_subprocess)uvicorn/loops/uvloop.pyimport asyncioimport uvloopdef uvloop_setup(use_subprocess: bool = False) -&gt; None: asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) ç¼ºç‚¹ ç›®å‰ä¸æ”¯æŒ windows çŸ¥è¯†ç‚¹ 2ASGIï¼ˆAsynchronous Server Gateway Interfaceï¼‰æ˜¯ä¸€ä¸ªç”¨äºç½‘ç»œåº”ç”¨çš„å¼‚æ­¥Pythonæ¡†æ¶æ¥å£ï¼Œç”¨äºå¤„ç†HTTPå’ŒWebSocketè¯·æ±‚ã€‚ASGIæ˜¯åŒæ­¥WSGIï¼ˆWeb Server Gateway Interfaceï¼‰æ¥å£çš„å¼‚æ­¥ç»§ä»»è€…ï¼Œå®ƒå…è®¸ä½¿ç”¨Pythonç¼–å†™çš„å¼‚æ­¥æ¡†æ¶æ¥æ„å»ºé«˜æ€§èƒ½çš„Webåº”ç”¨, ä¸ºä»€ä¹ˆä½¿ç”¨ ASGI Most well established Python Web frameworks started out as WSGI-based frameworks. å¤§å¤šæ•°æˆç†Ÿçš„ Python Web æ¡†æ¶æœ€åˆéƒ½æ˜¯åŸºäº WSGI çš„æ¡†æ¶ã€‚ WSGI applications are a single, synchronous callable that takes a request and returns a response. This doesnâ€™t allow for long-lived connections, like you get with long-poll HTTP or WebSocket connections, which WSGI doesnâ€™t support well. WSGI åº”ç”¨ç¨‹åºæ˜¯ä¸€ä¸ªå•ä¸€çš„åŒæ­¥å¯è°ƒç”¨å¯¹è±¡ï¼Œå®ƒæ¥å—ä¸€ä¸ªè¯·æ±‚å¹¶è¿”å›ä¸€ä¸ªå“åº”ã€‚è¿™ä¸å…è®¸é•¿æ—¶é—´ä¿æŒè¿æ¥ï¼Œä¾‹å¦‚ä½ åœ¨é•¿è½®è¯¢ HTTP æˆ– WebSocket è¿æ¥ä¸­æ‰€è·å¾—çš„é‚£ç§ï¼Œè€Œ WSGI å¯¹è¿™äº›å¹¶ä¸æ”¯æŒå¾—å¾ˆå¥½ã€‚ Having an async concurrency model also allows for options such as lightweight background tasks, and can be less of a limiting factor for endpoints that have long periods being blocked on network I&#x2F;O such as dealing with slow HTTP requests. é‡‡ç”¨å¼‚æ­¥å¹¶å‘æ¨¡å‹è¿˜å¯ä»¥å®ç°è½»é‡çº§çš„åå°ä»»åŠ¡ï¼Œå¯ä»¥æ›´å°‘çš„è¢«é‚£äº›é•¿æ—¶é—´è¢«ç½‘ç»œI&#x2F;Oï¼ˆå¦‚å¤„ç†ç¼“æ…¢çš„HTTPè¯·æ±‚ï¼‰é˜»å¡çš„ç«¯ç‚¹æ‰€é™åˆ¶ã€‚ æ–‡æ¡£é“¾æ¥: https://www.uvicorn.org/#the-asgi-interface æœ€ç®€å•çš„ ASGI åº”ç”¨ 1234567891011121314async def app(scope, receive, send): assert scope[&#x27;type&#x27;] == &#x27;http&#x27; await send(&#123; &#x27;type&#x27;: &#x27;http.response.start&#x27;, &#x27;status&#x27;: 200, &#x27;headers&#x27;: [ [b&#x27;content-type&#x27;, b&#x27;text/plain&#x27;], ], &#125;) await send(&#123; &#x27;type&#x27;: &#x27;http.response.body&#x27;, &#x27;body&#x27;: b&#x27;Hello, world!&#x27;, &#125;) scope http çš„å†…å®¹ï¼š 1234567891011121314scope = &#123; &quot;type&quot;: &quot;http&quot;, &quot;http_version&quot;: &quot;1.1&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;scheme&quot;: &quot;https&quot;, &quot;path&quot;: &quot;/&quot;, &quot;query_string&quot;: b&quot;search=red+blue&amp;maximum_price=20&quot;, &quot;headers&quot;: [ (b&quot;host&quot;, b&quot;www.example.org&quot;), (b&quot;accept&quot;, b&quot;application/json&quot;) ], &quot;client&quot;: (&quot;134.56.78.4&quot;, 1453), &quot;server&quot;: (&quot;www.example.org&quot;, 443)&#125; ä¸ wsgi çš„ environ å­—å…¸éå¸¸ç›¸ä¼¼ 12345678910111213environ = &#123; &quot;REQUEST_METHOD&quot;: &quot;GET&quot;, &quot;SCRIPT_NAME&quot;: &quot;&quot;, &quot;PATH_INFO&quot;: &quot;/&quot;, &quot;QUERY_STRING&quot;: &quot;search=red+blue&amp;maximum_price=20&quot;, &quot;SERVER_NAME&quot;: &quot;www.example.org&quot;, &quot;SERVER_PORT&quot;: 443, &quot;REMOTE_HOST&quot;: &quot;134.56.78.4&quot;, &quot;REMOTE_PORT&quot;: 1453, &quot;SERVER_PROTOCOL&quot;: &quot;HTTP/1.1&quot;, &quot;HTTP_HOST&quot;: &quot;www.example.org&quot;, &quot;HTTP_ACCEPT&quot;: &quot;application/json&quot;,&#125; å®é™…ä¸Šå®˜è®¿æ–‡æ¡£ä¹Ÿè§£é‡Šäº†ä¸¤è€…ä¹‹é—´çš„å…¼å®¹æ€§ï¼šhttps://asgi.readthedocs.io/en/latest/specs/www.html#wsgi-compatibility æºç ç»“æ„1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253â”œâ”€lifespanâ”‚ â”‚ off.pyâ”‚ â”‚ on.pyâ”‚ â”‚ __init__.pyâ”‚â”œâ”€loopsâ”‚ â”‚ asyncio.pyâ”‚ â”‚ auto.pyâ”‚ â”‚ uvloop.pyâ”‚ â”‚ __init__.pyâ”‚â”œâ”€middlewareâ”‚ â”‚ asgi2.pyâ”‚ â”‚ message_logger.pyâ”‚ â”‚ proxy_headers.pyâ”‚ â”‚ wsgi.pyâ”‚ â”‚ __init__.pyâ”‚â”œâ”€protocolsâ”‚ â”‚ utils.pyâ”‚ â”‚ __init__.pyâ”‚ â”‚â”‚ â”œâ”€httpâ”‚ â”‚ â”‚ auto.pyâ”‚ â”‚ â”‚ flow_control.pyâ”‚ â”‚ â”‚ h11_impl.pyâ”‚ â”‚ â”‚ httptools_impl.pyâ”‚ â”‚ â”‚ __init__.pyâ”‚ â”‚â”‚ â”œâ”€websocketsâ”‚ â”‚ â”‚ auto.pyâ”‚ â”‚ â”‚ websockets_impl.pyâ”‚ â”‚ â”‚ wsproto_impl.pyâ”‚ â”‚ â”‚ __init__.pyâ”‚â”œâ”€supervisorsâ”‚ â”‚ basereload.pyâ”‚ â”‚ multiprocess.pyâ”‚ â”‚ statreload.pyâ”‚ â”‚ watchfilesreload.pyâ”‚ â”‚ watchgodreload.pyâ”‚ â”‚ __init__.pyâ”‚â”‚ config.pyâ”‚ importer.pyâ”‚ logging.pyâ”‚ main.pyâ”‚ server.pyâ”‚ workers.pyâ”‚ _subprocess.pyâ”‚ _types.pyâ”‚ __init__.pyâ”‚ __main__.py lifespan å‘Šè¯‰åŸºäº ASGI çš„åº”ç”¨ç¨‹åºuvicornå³å°†å¯åŠ¨å’Œåœæ­¢çš„æ—¶é—´ï¼Œ uvicorn åœ¨å¯åŠ¨çš„æ—¶å€™ä¼šåˆå§‹åŒ–ï¼Œç„¶åå‘é€åˆå§‹åŒ–åè®®å¹¶ç­‰å¾…ASGIåº”ç”¨ç¨‹åºè¿”å›ï¼Œ å¦‚æœASGIåº”ç”¨ç¨‹åºè¿”å› complele åˆ™ uvicorn ä¼šç»§ç»­è¿è¡Œï¼Œ è¿”å› failed åˆ™æŠ¥é”™é€€å‡º æˆ‘ä»¬å…ˆçœ‹ lifespan è¿™ä¸ªç›®å½•æœ‰ä»€ä¹ˆ 123456789101112131415161718192021222324252627282930313233343536373839class LifespanOn: def __init__(self, config: Config) -&gt; None: self.logger = logging.getLogger(&quot;uvicorn.error&quot;) self.startup_event = asyncio.Event() self.shutdown_event = asyncio.Event() self.receive_queue: Queue[LifespanReceiveMessage] = asyncio.Queue() ... async def startup(self) -&gt; None: self.logger.info(&quot;Waiting for application startup.&quot;) # è·å–äº‹ä»¶å¾ªç¯ loop = asyncio.get_event_loop() # è¿™é‡Œåªæ˜¯åˆ›å»ºäº†ä»»åŠ¡ï¼Œè®©å…¶åœ¨äº‹ä»¶å¾ªç¯ä¸­ç­‰å¾…æ‰§è¡Œï¼Œåˆ›å»ºå˜é‡åŸå› æ˜¯æ·»åŠ  hard reference, é¿å…è¢« python è‡ªåŠ¨ gc main_lifespan_task = loop.create_task(self.main()) # noqa: F841 # Keep a hard reference to prevent garbage collection # See https://github.com/encode/uvicorn/pull/972 startup_event: LifespanStartupEvent = &#123;&quot;type&quot;: &quot;lifespan.startup&quot;&#125; # å‘é€å¯åŠ¨äº‹ä»¶åˆ°é˜Ÿåˆ— await self.receive_queue.put(startup_event) await self.startup_event.wait() if self.startup_failed or (self.error_occured and self.config.lifespan == &quot;on&quot;): self.logger.error(&quot;Application startup failed. Exiting.&quot;) self.should_exit = True else: self.logger.info(&quot;Application startup complete.&quot;) async def main(self) -&gt; None: try: app = self.config.loaded_app scope: LifespanScope = &#123; &quot;type&quot;: &quot;lifespan&quot;, &quot;asgi&quot;: &#123;&quot;version&quot;: self.config.asgi_version, &quot;spec_version&quot;: &quot;2.0&quot;&#125;, &quot;state&quot;: self.state, &#125; await app(scope, self.receive, self.send) except BaseException as exc: ... asyncio.Event() å¯¹è±¡çš„ä½¿ç”¨ 123456789101112131415161718192021222324252627282930313233import asyncioasync def waiter(event): print(&quot;Waiter is waiting for the event to be set.&quot;) await event.wait() print(&quot;Waiter has been awakened.&quot;)async def setter(event): print(&quot;Setter is going to set the event.&quot;) await asyncio.sleep(1) # æ¨¡æ‹Ÿä¸€äº›å¼‚æ­¥æ“ä½œ event.set() print(&quot;Event has been set.&quot;)async def main(): event = asyncio.Event() waiter_task = asyncio.create_task(waiter(event)) setter_task = asyncio.create_task(setter(event)) # ç­‰å¾…ä¸¤ä¸ªä»»åŠ¡éƒ½å®Œæˆ await waiter_task await setter_taskasyncio.run(main())# è¾“å‡ºWaiter is waiting for the event to be set.Setter is going to set the event.Event has been set.Waiter has been awakened. LifespanOff æ¯”è¾ƒç®€å• 12345678910class LifespanOff: def __init__(self, config: Config) -&gt; None: self.should_exit = False self.state: dict[str, Any] = &#123;&#125; async def startup(self) -&gt; None: pass async def shutdown(self) -&gt; None: pass loopsè‡ªåŠ¨åŠ è½½äº‹ä»¶å¾ªç¯ï¼Œ ä¼˜å…ˆåŠ è½½ uvloop å‚è€ƒä¸Šæ–‡ çŸ¥è¯†ç‚¹ 1 middleware é‡Œé¢æ˜¯ä¸€äº›ç®€å•é€šç”¨çš„ä¸­é—´ä»¶ PS: è¿™é‡Œçš„ä¸­é—´ä»¶å’Œ fastapi ä¸­çš„ä¸­é—´ä»¶æ˜¯ä¸åŒçš„ï¼Œfastapi çš„ä¸­é—´ä»¶æ˜¯ä¸€ä¸ª ASGI åº”ç”¨ä¸­ä¸Šä¸‹æ–‡çš„åˆ‡å‰²ï¼Œè¿™é‡Œçš„ä¸­é—´ä»¶å°±æ˜¯ä¸€ä¸ª ASGI åº”ç”¨ wsgi.py å°† ASGI æœåŠ¡è½¬æˆ WSGI æœåŠ¡ message_logger.py ä¼ é€’æ¶ˆæ¯çš„ä¸­é—´ä»¶ proxy_headers.py ä¸€ä¸ªåº”ç”¨ç¨‹åºé€šè¿‡ä»£ç†ï¼ˆå¦‚Nginxã€Apacheç­‰ï¼‰ä¸å®¢æˆ·ç«¯è¿æ¥æ—¶ï¼Œå®¢æˆ·ç«¯çš„è¯·æ±‚ä¼šå…ˆç»è¿‡ä»£ç†æœåŠ¡å™¨ï¼Œç„¶åå†è½¬å‘ç»™åº”ç”¨ç¨‹åºã€‚ä»£ç†æœåŠ¡å™¨åœ¨è½¬å‘æ—¶ï¼Œä¼šæ·»åŠ ä¸€äº›ç‰¹æ®Šçš„HTTPå¤´éƒ¨ï¼Œæ¯”å¦‚ï¼š X-Forwarded-Forï¼šè®°å½•åŸå§‹å®¢æˆ·ç«¯çš„IPåœ°å€ã€‚ X-Forwarded-Protoï¼šè®°å½•å®¢æˆ·ç«¯ä½¿ç”¨çš„åè®®ï¼ˆHTTPæˆ–HTTPSï¼‰ã€‚ ç„¶è€Œï¼Œå½“åº”ç”¨ç¨‹åºæ”¶åˆ°è¯·æ±‚æ—¶ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå®ƒä¼šè®¤ä¸ºè¯·æ±‚æ˜¯ä»ä»£ç†æœåŠ¡å™¨è€Œä¸æ˜¯ä»åŸå§‹å®¢æˆ·ç«¯å‘æ¥çš„ã€‚æ‰€ä»¥ï¼Œå®¢æˆ·ç«¯çš„IPå’Œåè®®ä¿¡æ¯å¯èƒ½ä¼šè¢«ä»£ç†çš„IPå’Œåè®®è¦†ç›–ã€‚ è¿™ä¸ªä¸­é—´ä»¶çš„ä½œç”¨å°±æ˜¯è®©åº”ç”¨ç¨‹åºä½¿ç”¨ä»£ç†æœåŠ¡å™¨ä¼ é€’è¿‡æ¥çš„è¿™äº›å¤´éƒ¨ä¿¡æ¯ï¼Œä»è€Œè·å–åˆ°åŸå§‹å®¢æˆ·ç«¯çš„IPåœ°å€å’Œåè®®ï¼Œè€Œä¸æ˜¯ä»£ç†æœåŠ¡å™¨çš„IPå’Œåè®®ã€‚è¿™æ ·ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥çŸ¥é“çœŸæ­£å‘èµ·è¯·æ±‚çš„å®¢æˆ·ç«¯æ˜¯è°ï¼Œä»¥åŠä»–ä»¬ä½¿ç”¨çš„æ˜¯HTTPè¿˜æ˜¯HTTPSã€‚ protocols é‡Œé¢å­˜æ”¾ç€è¯»å–è¿æ¥æ•°æ®å’Œè§£ææ¶ˆæ¯ä½“çš„åè®®ï¼Œ å¦‚ HTTP å’Œ WebSockets, å¯ä»¥æŠŠä»–è®¤ä¸ºæ˜¯ä¸€ä¸ªåºåˆ—åŒ–å™¨ã€‚ åŸºç¡€åè®®uvicorn å°è£…çš„å¯¹è±¡ç»§æ‰¿äº asyncio.Protocol, å®ƒæ˜¯é’ˆå¯¹TCPåè®®çš„å°è£…ï¼ŒåŒ…å«ä»¥ä¸‹å…­ä¸ªæ–¹æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243class BaseProtocol: def connection_made(self, transport): &quot;&quot;&quot; åœ¨å»ºç«‹è¿æ¥æ—¶è°ƒç”¨. å‚æ•°æ˜¯è¡¨ç¤ºç®¡é“è¿æ¥çš„transport, æ­¤æ—¶å¾—åˆ°çš„transportéœ€è¦è®¾ç½®ä¸ºè¯¥ç±»çš„transportï¼Œ æ–¹ä¾¿åç»­connection_lostæ§åˆ¶å…³é—­ç®¡é“. &quot;&quot;&quot; def connection_lost(self, exc): &quot;&quot;&quot; å½“è¿æ¥ä¸¢å¤±æˆ–å…³é—­æ—¶è°ƒç”¨, æ ¹æ®excåˆ¤æ–­æ˜¯å¦è¦å…³é—­trnasport. å‚æ•°æ˜¯ä¸€ä¸ªå¼‚å¸¸å¯¹è±¡æˆ–None(åè€…è¡¨ç¤ºæ¥æ”¶åˆ°å¸¸è§„EOFæˆ–ä¸­æ­¢æˆ–å…³é—­è¿æ¥). &quot;&quot;&quot; def pause_writing(self): &quot;&quot;&quot; å½“transportç¼“å†²åŒºè¶…è¿‡é«˜æ°´ä½(high-water mark)æ—¶è°ƒç”¨, æ­¤æ—¶åº”è¯¥èƒ½æ§åˆ¶å¤–éƒ¨ä¸å†å†™å…¥æ•°æ®ï¼ˆé€šå¸¸æ˜¯ä¸€ä¸ªasyncio.Futureï¼‰, åŒæ—¶åº”è¯¥é€šè¿‡transport.pause_readingæ¥åœæ­¢è·å–æ•°æ®ï¼Œ ä¹‹åTCPå°±ä¼šé€šè¿‡æ‹¥å¡æœºåˆ¶ä½¿å¾—å®¢æˆ·ç«¯å‡ç¼“å‘é€æ•°æ®çš„é€Ÿåº¦ã€‚ &quot;&quot;&quot; def resume_writing(self): &quot;&quot;&quot; å½“transportç¼“å†²åŒºæ’æ”¾ä½äºä½æ°´ä½çº¿(low-water mark)æ—¶è°ƒç”¨. æ­¤æ—¶è¦é‡Šæ”¾æ ‡å¿—ï¼Œ ä½¿å¾—å¤–éƒ¨å¯ä»¥ç»§ç»­å†™å…¥æ•°æ®ï¼Œ åŒæ—¶é€šè¿‡transport.resume_readingæ¥æ¢å¤è·å–æ•°æ®ï¼Œ ä¹‹åTCPå°±ä¼šé€šè¿‡æ‹¥å¡æœºåˆ¶çŸ¥é“æœåŠ¡ç«¯çš„å¤„ç†èƒ½åŠ›ä¸Šæ¥äº†ï¼Œ ä½¿å®¢æˆ·ç«¯åŠ å¿«å‘é€é€Ÿåº¦ã€‚ &quot;&quot;&quot;class Protocol(BaseProtocol): def data_received(self, data): &quot;&quot;&quot; é€šè¿‡è¯¥æ–¹æ³•å¯ä»¥è·å–åˆ°å®¢æˆ·ç«¯ä¼ è¾“è¿‡æ¥çš„æ•°æ® &quot;&quot;&quot; def eof_received(self): &quot;&quot;&quot; å½“å¦ä¸€ç«¯è°ƒç”¨write_eof()æˆ–ç­‰æ•ˆå‡½æ•°æ—¶è°ƒç”¨. å¦‚æœè¿”å›ä¸€ä¸ªå‡å€¼(åŒ…æ‹¬None)ï¼Œåˆ™ä¼ è¾“å°†å…³é—­è‡ªèº«ã€‚ å¦‚æœå®ƒè¿”å›trueå€¼ï¼Œåˆ™å…³é—­ä¼ è¾“å–å†³äºåè®®. &quot;&quot;&quot; é€šè¿‡è¿™äº›æˆ‘ä»¬è¿˜ä¸çŸ¥é“ uvicorn åšäº†å“ªäº›ä¿®æ”¹æ¥è¾¾åˆ°è·Ÿåº”ç”¨ç¨‹åºè¿›è¡Œé€šä¿¡ï¼Œæ‰€ä»¥æˆ‘ä»¬æ¥ç€çœ‹ä¸€ä¸‹ uvicorn çš„å…·ä½“å®ç° httpé‡Œé¢æœ‰ä¸¤ç§å®ç°ï¼šhttptools å’Œ h11_impl httptools æ˜¯ä¸€ä¸ªç”¨ C è¯­è¨€ç¼–å†™çš„é«˜æ€§èƒ½ HTTP åº“ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªå¿«é€Ÿçš„ HTTP è§£æå™¨å’Œç”Ÿæˆå™¨ã€‚ç”±äºå®ƒæ˜¯ç”¨ C ç¼–å†™çš„ï¼Œå› æ­¤å¯ä»¥æä¾›æ¯”çº¯ Python åº“æ›´é«˜çš„æ€§èƒ½ã€‚httptools é€šå¸¸ç”¨äºæ„å»ºé«˜æ€§èƒ½çš„ Web æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦å¤„ç†å¤§é‡å¹¶å‘è¿æ¥æ—¶ã€‚ h11 æ˜¯ä¸€ä¸ªçº¯ Python ç¼–å†™çš„ HTTP&#x2F;1.1 åè®®çš„å®ç°ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªç®€å•ã€æ˜ç¡®çš„ API æ¥å¤„ç† HTTP æ¶ˆæ¯ã€‚h11 çš„è®¾è®¡ç›®æ ‡æ˜¯æ˜“äºç†è§£å’Œä½¿ç”¨ï¼Œè€Œä¸æ˜¯è¿½æ±‚æœ€é«˜æ€§èƒ½ã€‚ httptools çš„å†…å®¹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class ServerState: &quot;&quot;&quot; Shared servers state that is available between all protocol instances. &quot;&quot;&quot; def __init__(self) -&gt; None: self.total_requests = 0 self.connections: set[Protocols] = set() self.tasks: set[asyncio.Task[None]] = set() self.default_headers: list[tuple[bytes, bytes]] = []class HttpToolsProtocol(asyncio.Protocol): def __init__( self, config: Config, server_state: ServerState, app_state: dict[str, Any], _loop: asyncio.AbstractEventLoop | None = None, ) -&gt; None: if not config.loaded: config.load() self.config = config self.app = config.loaded_app self.loop = _loop or asyncio.get_event_loop() self.logger = logging.getLogger(&quot;uvicorn.error&quot;) self.access_logger = logging.getLogger(&quot;uvicorn.access&quot;) # ä¼ å…¥äº† self self.parser = httptools.HttpRequestParser(self) # server_state å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå®¹å™¨ self.server_state = server_state self.connections = server_state.connections self.tasks = server_state.tasks # Per-connection state self.transport: asyncio.Transport = None # type: ignore[assignment] self.flow: FlowControl = None # type: ignore[assignment] # è¯·æ±‚å¤„ç†æµç¨‹çš„åŒç«¯é˜Ÿåˆ— self.pipeline: deque[tuple[RequestResponseCycle, ASGI3Application]] = deque() def connection_made( # type: ignore[override] self, transport: asyncio.Transport ) -&gt; None: # æ·»åŠ å®ä¾‹æœ¬èº«åˆ°é›†åˆï¼Œ ä»£è¡¨å½“å‰è¿˜æœ‰è¿æ¥åœ¨å¤„ç† self.connections.add(self) self.transport = transport # åˆå§‹åŒ–æµæ§åˆ¶ self.flow = FlowControl(transport) # ç®€å•çš„åˆå§‹åŒ–å®ä¾‹trsnaportçš„ç›¸å…³ç¼–åˆ— self.server = get_local_addr(transport) self.client = get_remote_addr(transport) self.scheme = &quot;https&quot; if is_ssl(transport) else &quot;http&quot; if self.logger.level &lt;= TRACE_LOG_LEVEL: prefix = &quot;%s:%d - &quot; % self.client if self.client else &quot;&quot; self.logger.log(TRACE_LOG_LEVEL, &quot;%sHTTP connection made&quot;, prefix) def connection_lost(self, exc: Exception | None) -&gt; None: # ä»é›†åˆåˆ é™¤å®ä¾‹æœ¬èº«ï¼Œ ä»£è¡¨å½“å‰è¿æ¥å·²ç»å¤„ç†ç©äº†ï¼Œ ä¸éœ€è¦è¿›å…¥ç»Ÿè®¡å®¹å™¨ self.connections.discard(self) if self.logger.level &lt;= TRACE_LOG_LEVEL: prefix = &quot;%s:%d - &quot; % self.client if self.client else &quot;&quot; self.logger.log(TRACE_LOG_LEVEL, &quot;%sHTTP connection lost&quot;, prefix) # è®¾ç½®cycleï¼Œ å‘Šè¯‰ä»–è¿æ¥å·²ç»æ–­å¼€ if self.cycle and not self.cycle.response_complete: self.cycle.disconnected = True if self.cycle is not None: self.cycle.message_event.set() if self.flow is not None: self.flow.resume_writing() if exc is None: self.transport.close() self._unset_keepalive_if_required() self.parser = None def _unset_keepalive_if_required(self): &quot;&quot;&quot;å–æ¶ˆkeep alive timeoutçš„ä»»åŠ¡ï¼Œ ä¸€èˆ¬æ¥è¯´ï¼Œ åœ¨å‘é€æ•°æ®åæœåŠ¡ç«¯ä¼šç­‰å¾…å®¢æˆ·ç«¯å‘é€æ•°æ®ï¼Œ å¦‚æœè¶…è¿‡å¤šå°‘ç§’æ²¡æœ‰å‘é€æ•°æ®åˆ™å¯ä»¥åˆ¤æ–­è¯¥å®¢æˆ·ç«¯å·²ç»æ–­å¼€äº†ï¼Œ æœåŠ¡ç«¯å¯ä»¥ä¸»åŠ¨å…³é—­è¿æ¥ è€Œuvicorné€šè¿‡timeout_keep_alive_taskæ¥å®ç° &quot;&quot;&quot; if self.timeout_keep_alive_task is not None: self.timeout_keep_alive_task.cancel() self.timeout_keep_alive_task = None def data_received(self, data): self._unset_keepalive_if_required() try: # æ¥å—å­—èŠ‚æ•°æ®ï¼Œ å¹¶äº¤ç”±httpè§£æå™¨è¿›è¡Œè§£æ self.parser.feed_data(data) except httptools.HttpParserError as exc: # è§£æå¤±è´¥ï¼Œ åº”è¯¥ä¸æ˜¯httpåè®®çš„æ•°æ®ï¼Œ æ–­å¼€è¿æ¥ msg = &quot;Invalid HTTP request received.&quot; self.logger.warning(msg, exc_info=exc) self.transport.close() except httptools.HttpParserUpgrade: # å·²ç»è¶…è¿‡äº†è§£æå™¨èƒ½è§£æçš„åè®®ç‰ˆæœ¬ï¼Œ åº”è¯¥äº¤ç”±æ›´æ–°çš„åè®®è§£æå™¨å¤„ç† self.handle_upgrade() è¯¥ç±»ä¸­è¿˜æœ‰å¾ˆå¤š on_xxx çš„æ–¹æ³•å¹¶æ²¡æœ‰è¢«è°ƒç”¨ï¼Œæ˜¯å› ä¸ºåœ¨åˆå§‹åŒ–HTTPåè®®è§£æå™¨çš„æ—¶å€™ï¼Œuvicorn.protocol æŠŠè‡ªå·±çš„å®ä¾‹ä¼ å…¥äº†HTTPè§£æå™¨ä¸­ï¼Œ è§£æå™¨ä¼šè¾¹æ¥æ”¶æ•°æ®è¾¹æŒ‰ç…§url, header, bodyæ¥é¡ºåºè§£æï¼Œ å¹¶åœ¨æ‰§è¡Œæ¯ç§æ•°æ®è§£æåï¼Œ ä¼šé€šè¿‡å›è°ƒå‘Šè¯‰ä¼ å…¥çš„å®ä¾‹ï¼Œ uvicorn æ­£æ˜¯é€šè¿‡on_xxx æ–¹æ³•æ¥ç›‘å¬è¿™äº›å›è°ƒå¹¶å¤„ç†è§£æå®Œçš„HTTPæ•°æ® å¯ä»¥çœ‹ httptools çš„ parser æºç ï¼Œæ˜¯ CPython å†™çš„: https://github.com/MagicStack/httptools/blob/master/httptools/parser/parser.pyx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133class HttpToolsProtocol(asyncio.Protocol): def on_message_begin(self) -&gt; None: # æ¥æ”¶åˆ°è¯·æ±‚çš„ç¬¬ä¸€æ¬¡è§£æï¼Œä¸»è¦ä½œç”¨æ˜¯åˆå§‹åŒ– scope self.url = b&quot;&quot; self.expect_100_continue = False self.headers = [] self.scope = &#123; # type: ignore[typeddict-item] &quot;type&quot;: &quot;http&quot;, &quot;asgi&quot;: &#123;&quot;version&quot;: self.config.asgi_version, &quot;spec_version&quot;: &quot;2.4&quot;&#125;, &quot;http_version&quot;: &quot;1.1&quot;, &quot;server&quot;: self.server, &quot;client&quot;: self.client, &quot;scheme&quot;: self.scheme, # type: ignore[typeddict-item] &quot;root_path&quot;: self.root_path, &quot;headers&quot;: self.headers, &quot;state&quot;: self.app_state.copy(), &#125; # Parser callbacks def on_url(self, url: bytes) -&gt; None: self.url += url def on_header(self, name: bytes, value: bytes) -&gt; None: &quot;&quot;&quot;è§£æå™¨åœ¨è§£æheaderæ—¶ï¼Œ æ˜¯æŒ‰ç…§headerä¸€è¡Œä¸€è¡Œè¿›è¡Œè§£æçš„ï¼Œ æ‰€ä»¥æ¯ä¸€è¡Œheaderéƒ½ä¼šè°ƒç”¨ä¸€æ¬¡on_header, å¹¶æŠŠä»–ä»¬å­˜åœ¨å®ä¾‹çš„headersä¸­&quot;&quot;&quot; name = name.lower() if name == b&quot;expect&quot; and value.lower() == b&quot;100-continue&quot;: self.expect_100_continue = True self.headers.append((name, value)) def on_headers_complete(self) -&gt; None: http_version = self.parser.get_http_version() method = self.parser.get_method() self.scope[&quot;method&quot;] = method.decode(&quot;ascii&quot;) if http_version != &quot;1.1&quot;: self.scope[&quot;http_version&quot;] = http_version if self.parser.should_upgrade() and self._should_upgrade(): # å¦‚æœå‘ç°å½“å‰httpç‰ˆæœ¬æ›´åŠ é«˜çº§ï¼ˆæ¯”å¦‚websocketï¼‰, åˆ™ä¸å†å¤„ç†, åœ¨å¦å¤–ä¸€ä¸ªé€»è¾‘ä¼šè½¬åˆ°websocketå¤„ç† return parsed_url = httptools.parse_url(self.url) raw_path = parsed_url.path path = raw_path.decode(&quot;ascii&quot;) if &quot;%&quot; in path: path = urllib.parse.unquote(path) full_path = self.root_path + path full_raw_path = self.root_path.encode(&quot;ascii&quot;) + raw_path self.scope[&quot;path&quot;] = full_path self.scope[&quot;raw_path&quot;] = full_raw_path self.scope[&quot;query_string&quot;] = parsed_url.query or b&quot;&quot; # Handle 503 responses when &#x27;limit_concurrency&#x27; is exceeded. if self.limit_concurrency is not None and ( len(self.connections) &gt;= self.limit_concurrency or len(self.tasks) &gt;= self.limit_concurrency ): # å½“å‰å¹¶å‘æ•°è¿‡é«˜ï¼Œ ä¸å†è½¬å‘ç»™åé¢çš„åº”ç”¨ç¨‹åºï¼Œ ç›´æ¥è¿”å›é”™è¯¯, è¿™é‡Œæ˜¯ä¸€ä¸ªå…·æœ‰ASGIæ ‡å‡†å‡½æ•°ç­¾åçš„å‡½æ•°, é‡Œé¢å®ç°çš„åŠŸèƒ½æ˜¯å‘é€é”™è¯¯ä¿¡æ¯åˆ°socket app = service_unavailable message = &quot;Exceeded concurrency limit.&quot; self.logger.warning(message) else: app = self.app # cycle ç›¸å½“äºä¸€ä¸ª request çš„å¤„ç†æµç¨‹,æ™®é€šçš„HTTPè¯·æ±‚åªå¯¹åº”ä¸€ä¸ªcycleå°±å¯ä»¥äº†ï¼Œè¿™é‡Œæ˜¯å…¼å®¹Pipeline HTTPè¯·æ±‚ existing_cycle = self.cycle self.cycle = RequestResponseCycle( scope=self.scope, transport=self.transport, flow=self.flow, logger=self.logger, access_logger=self.access_logger, access_log=self.access_log, default_headers=self.server_state.default_headers, message_event=asyncio.Event(), expect_100_continue=self.expect_100_continue, keep_alive=http_version != &quot;1.0&quot;, on_response=self.on_response_complete, ) if existing_cycle is None or existing_cycle.response_complete: # Standard case - start processing the request. # å¦‚æœä¸Šä¸ªè¯·æ±‚å·²ç»å¤„ç†å®Œäº†ï¼Œ åˆ™å¼€å§‹å¤„ç†è¿™ä¸ªè¯·æ±‚(é€šè¿‡run_asgiæ¥è¿è¡Œ) task = self.loop.create_task(self.cycle.run_asgi(app)) task.add_done_callback(self.tasks.discard) self.tasks.add(task) else: # å¦‚æœä¸Šä¸ªè¯·æ±‚æ²¡æœ‰å¤„ç†å®Œ(æ¯”å¦‚ body æ²¡æœ‰æ¥æ”¶å®Œæ•´)ï¼Œ å°±å…ˆæš‚åœè¯»å–æ•°æ®ï¼Œ å¹¶æŠŠè¯¥cycleæ”¾åˆ°pipelineæš‚å­˜ # Pipelined HTTP requests need to be queued up. self.flow.pause_reading() self.pipeline.appendleft((self.cycle, app)) def on_body(self, body: bytes) -&gt; None: # ä¸€ä¸ªè¯·æ±‚å¯èƒ½ä¼šæœ‰å¤šæ¬¡ on_body è°ƒç”¨ï¼ŒåŒ…æ‹¬è¿™é‡Œå†å¾€åå°±æ²¡æœ‰ç›´æ¥è§£ææ•°æ®äº†ï¼Œä¸€èˆ¬ä¼šå‘é€åˆ°çœŸæ­£å¤„ç†çš„åº”ç”¨ç¨‹åºï¼ˆASGIåº”ç”¨ï¼‰ if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete: return # å°† body ç´¯è®¡åˆ° cycle ä¸­ self.cycle.body += body if len(self.cycle.body) &gt; HIGH_WATER_LIMIT: # ç”±äºASGIåº”ç”¨ç¨‹åºä¼šæ ¹æ®è°ƒç”¨è€…éœ€è¦æ‰æ¥è·å–body(æ¯”å¦‚starletteçš„ await request.body())ï¼Œ å¦‚æœåº”ç”¨ç¨‹åºæ²¡æœ‰éœ€è¦åˆ™ä¼šæš‚ç¼“è·å–bodyæ•°æ® self.flow.pause_reading() # å‘Šè¯‰ASGIåº”ç”¨ç¨‹åºï¼Œ bodyå·²ç»è·å–ç»“æŸï¼ˆé€šå¸¸åœ¨cycleçš„more_bodyä¸ºFalseçš„æ—¶å€™, æ‰ä¼šæ£€æŸ¥message_eventï¼‰ self.cycle.message_event.set() def on_message_complete(self) -&gt; None: if (self.parser.should_upgrade() and self._should_upgrade()) or self.cycle.response_complete: return # è¡¨ç¤ºbodyå·²ç»è¯»å–ç»“æŸäº† self.cycle.more_body = False self.cycle.message_event.set() def on_response_complete(self) -&gt; None: # Callback for pipelined HTTP requests to be started. self.server_state.total_requests += 1 if self.transport.is_closing(): return # è®¾ç½®ä¸€ä¸ªkeep_aliveçš„æœºåˆ¶ï¼Œ æœåŠ¡ç«¯è¿”å›å“åº”åä¼šè®¾ç½®ä¸€ä¸ªå€’è®¡æ—¶future, è¯¥futureåªæœ‰åœ¨ä¸Šé¢data_receivedæ”¶åˆ°è¯·æ±‚çš„æ—¶å€™æ‰ä¼šå–æ¶ˆ # å¦‚æœè¯¥futureæ²¡æœ‰å–æ¶ˆï¼Œ åˆ™ä¼šè°ƒç”¨timeout_keep_alive_handlerå‡½æ•°æ¥å…³é—­transporté€šé“ self._unset_keepalive_if_required() # Unpause data reads if needed. self.flow.resume_reading() # Unblock any pipelined events. If there are none, arm the # Keep-Alive timeout instead. if self.pipeline: # å¦‚æœæ˜¯pipelineè¯·æ±‚ï¼Œ åˆ™å¼€å§‹å¤„ç†åˆšæ‰æš‚å­˜çš„cycle cycle, app = self.pipeline.pop() task = self.loop.create_task(cycle.run_asgi(app)) task.add_done_callback(self.tasks.discard) self.tasks.add(task) else: self.timeout_keep_alive_task = self.loop.call_later( self.timeout_keep_alive, self.timeout_keep_alive_handler ) PS: ä»€ä¹ˆæ˜¯ pipeline è¯·æ±‚ åœ¨ASGIçš„ä¸Šä¸‹æ–‡ä¸­ï¼Œä¸€ä¸ªè¯·æ±‚å¯èƒ½ä¸ä¼šç«‹å³å®Œæˆï¼Œè€Œæ˜¯ä¼šé€šè¿‡å¤šä¸ªäº‹ä»¶æ¥åˆ†é˜¶æ®µå¤„ç†ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªHTTPè¯·æ±‚å¯èƒ½é¦–å…ˆæ¥æ”¶åˆ°è¯·æ±‚å¤´ï¼Œç„¶åæ˜¯è¯·æ±‚ä½“çš„ä¸€éƒ¨åˆ†ï¼Œç„¶åæ˜¯æ›´å¤šçš„è¯·æ±‚ä½“ï¼Œç›´åˆ°æ‰€æœ‰çš„è¯·æ±‚ä½“éƒ½è¢«æ¥æ”¶ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥è¢«çœ‹ä½œæ˜¯ä¸€ä¸ªâ€pipelineâ€ï¼Œå…¶ä¸­è¯·æ±‚æ•°æ®åœ¨è¢«å®Œå…¨æ¥æ”¶å’Œå¤„ç†ä¹‹å‰ï¼Œä¼šé€šè¿‡ä¸åŒçš„é˜¶æ®µæµåŠ¨ã€‚ å¯ä»¥çœ‹åˆ°é‡Œé¢æœ‰ä¸€ä¸ª cycle å¯¹è±¡ï¼Œæ˜¯è´Ÿè´£ http å’Œ asgi æ•°æ®è½¬æ¢çš„å¯¹è±¡ï¼Œå®ƒæœ‰ send å’Œ receive ä¸¤ä¸ªæ–¹æ³• 1234567891011121314151617181920212223 async def send(self, message: ASGISendEvent) -&gt; None: # é€šè¿‡ä¼ å…¥çš„å‚æ•°messageè·å–åˆ°ASGIåº”ç”¨ç¨‹åºè¿”å›çš„æ•°æ®ï¼Œ å¹¶ä¾æ®ASGIåè®®è¿›è¡Œè§£æï¼Œ # å¹¶æ‹¼æ¥æˆHTTPåè®®çš„å­—èŠ‚æµï¼Œ å½“ASGIåº”ç”¨ç¨‹åºå‘é€ç»“æŸæ ‡è®°æ—¶ï¼Œ sendä¼šæŠŠæ‹¼æ¥çš„å­—èŠ‚ # æµé€šè¿‡socketè¿”å›ç»™å®¢æˆ·ç«¯, åŒæ—¶è§¦å‘on_response_complete æ–¹æ³•ã€‚ ... async def receive(self) -&gt; ASGIReceiveEvent: # å®ƒåªè´Ÿè´£æ¥æ”¶è·å–åˆ°å·²ç»è§£æå®Œæˆçš„HTTPæ•°æ®ï¼ˆå‰é¢on_xxxæ—¶ä¼šæŠŠæ•°æ®ä¼ ç»™cycleï¼‰ï¼Œ # ç„¶åå‘é€åˆ° ASGI åº”ç”¨ç¨‹åºä¸­ if self.waiting_for_100_continue and not self.transport.is_closing(): self.transport.write(b&quot;HTTP/1.1 100 Continue\\r \\r &quot;) self.waiting_for_100_continue = False if not self.disconnected and not self.response_complete: self.flow.resume_reading() await self.message_event.wait() self.message_event.clear() if self.disconnected or self.response_complete: return &#123;&quot;type&quot;: &quot;http.disconnect&quot;&#125; message: HTTPRequestEvent = &#123;&quot;type&quot;: &quot;http.request&quot;, &quot;body&quot;: self.body, &quot;more_body&quot;: self.more_body&#125; self.body = b&quot;&quot; return message websocketé‡Œé¢ä¹Ÿæœ‰ä¸¤ç§å®ç°ï¼šwebsockets å’Œ wsproto websockets æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ Python åº“ï¼Œç”¨äºæ„å»º WebSocket æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ã€‚å®ƒæä¾›äº†ä¸€ä¸ªé«˜çº§çš„ APIï¼Œå…è®¸å¼€å‘è€…è½»æ¾åœ°å®ç° WebSocket é€šä¿¡ã€‚websockets åº“å¤„ç†äº† WebSocket åè®®çš„å¤§éƒ¨åˆ†å¤æ‚æ€§ï¼ŒåŒ…æ‹¬æ¡æ‰‹ã€å¸§ç¼–ç å’Œè§£ç ã€å¿ƒè·³ä»¥åŠå…³é—­è¿‡ç¨‹ã€‚ wsproto æ˜¯ä¸€ä¸ªè¾ƒä½çº§åˆ«çš„ WebSocket åè®®åº“ï¼Œå®ƒæä¾›äº† WebSocket åè®®çš„å®ç°ï¼Œä½†ä¸åŒ…æ‹¬é«˜çº§çš„æ¡†æ¶æˆ–æœåŠ¡å™¨é€»è¾‘ã€‚wsproto ä¸»è¦ç”¨äºé‚£äº›éœ€è¦ç²¾ç»†æ§åˆ¶ WebSocket åè®®ç»†èŠ‚çš„åœºåˆï¼Œæˆ–è€…åœ¨æ€§èƒ½è¦æ±‚æé«˜çš„ç¯å¢ƒä¸­ã€‚ æµç¨‹å›¾ å¯ä»¥çœ‹åˆ° http è§£æå™¨ä¸­åªè§£æåˆ° headerï¼Œå…·ä½“çš„ body å†…å®¹æ˜¯äº¤ç»™ ASGI åº”ç”¨å»å¤„ç† supervisorsuvicornæœ¬èº«æ˜¯ä»¥ä¸€ä¸ªè¿›ç¨‹å¯åŠ¨çš„ï¼Œ è¿™ä¸ªæ–‡ä»¶å¤¹å­˜æ”¾ç€uvicornçš„å‡ ç§å¯åŠ¨æ–¹å¼ï¼Œ å¦‚å¤šè¿›ç¨‹å¯åŠ¨ï¼Œç›‘æ§æ–‡ä»¶å˜åŠ¨è‡ªåŠ¨é‡å¯çš„æ–¹å¼ç­‰ å¯åŠ¨work.pyé‡Œé¢æœ‰ä¸ªç±» UvicornWorker ç”¨äºgunicornå¯åŠ¨ uvicorn 1gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:80 logging.pyé‡Œé¢å®šä¹‰äº†ä¸€äº› formatter æ¯”å¦‚æ ¹æ®æ—¥å¿—ç­‰çº§æ¸²æŸ“ä¸åŒé¢œè‰²ç­‰ æ•´ä¸ªé¡¹ç›®ç”¨åˆ°äº†ä¸‰ä¸ª loggerï¼š uvicorn.error é”™è¯¯æ—¥å¿—æˆ–ç”Ÿå‘½å‘¨æœŸæ—¥å¿— uvicorn.access http è¯·æ±‚è®¿é—®æ—¥å¿— uvicorn.asgi ASGI åº”ç”¨ç›¸å…³çš„æ—¥å¿— æ—¥å¿—çš„å®šä¹‰ä½¿ç”¨äº† dictConfigï¼Œä¹‹å‰å€’æ˜¯æ²¡ç”¨è¿‡è¿™ç§æ–¹å¼é…ç½®æ—¥å¿—, æ„Ÿè§‰ä¸æ˜¯å¾ˆæ–¹ä¾¿ 1234567891011121314151617181920212223242526class Config: def configure_logging(self) -&gt; None: logging.addLevelName(TRACE_LOG_LEVEL, &quot;TRACE&quot;) if self.log_config is not None: if isinstance(self.log_config, dict): if self.use_colors in (True, False): self.log_config[&quot;formatters&quot;][&quot;default&quot;][&quot;use_colors&quot;] = self.use_colors self.log_config[&quot;formatters&quot;][&quot;access&quot;][&quot;use_colors&quot;] = self.use_colors logging.config.dictConfig(self.log_config) elif self.log_config.endswith(&quot;.json&quot;): with open(self.log_config) as file: loaded_config = json.load(file) logging.config.dictConfig(loaded_config) elif self.log_config.endswith((&quot;.yaml&quot;, &quot;.yml&quot;)): # Install the PyYAML package or the uvicorn[standard] optional # dependencies to enable this functionality. import yaml with open(self.log_config) as file: loaded_config = yaml.safe_load(file) logging.config.dictConfig(loaded_config) else: # See the note about fileConfig() here: # https://docs.python.org/3/library/logging.config.html#configuration-file-format logging.config.fileConfig(self.log_config, disable_existing_loggers=False) main.py123456789101112131415161718192021222324252627def run(app, **kwargs) -&gt; None: if app_dir is not None: sys.path.insert(0, app_dir) # åˆå§‹åŒ–é…ç½® config = Config(app, **kwargs) # åˆå§‹åŒ–æœåŠ¡ server = Server(config=config) if (config.reload or config.workers &gt; 1) and not isinstance(app, str): logger = logging.getLogger(&quot;uvicorn.error&quot;) logger.warning(&quot;You must pass the application as an import string to enable &#x27;reload&#x27; or &quot; &quot;&#x27;workers&#x27;.&quot;) sys.exit(1) if config.should_reload: sock = config.bind_socket() ChangeReload(config, target=server.run, sockets=[sock]).run() elif config.workers &gt; 1: sock = config.bind_socket() Multiprocess(config, target=server.run, sockets=[sock]).run() else: server.run() if config.uds and os.path.exists(config.uds): os.remove(config.uds) # pragma: py-win32 if not server.started and not config.should_reload and config.workers == 1: sys.exit(STARTUP_FAILURE) server.py12345678910111213141516171819202122232425262728293031323334class Server: def run(self, sockets: list[socket.socket] | None = None) -&gt; None: # è®¾ç½®å¾ªç¯ç­–ç•¥ self.config.setup_event_loop() # å¯åŠ¨æœåŠ¡ return asyncio.run(self.serve(sockets=sockets)) async def serve(self, sockets: list[socket.socket] | None = None) -&gt; None: with self.capture_signals(): await self._serve(sockets) async def _serve(self, sockets: list[socket.socket] | None = None) -&gt; None: process_id = os.getpid() config = self.config if not config.loaded: config.load() self.lifespan = config.lifespan_class(config) message = &quot;Started server process [%d]&quot; color_message = &quot;Started server process [&quot; + click.style(&quot;%d&quot;, fg=&quot;cyan&quot;) + &quot;]&quot; logger.info(message, process_id, extra=&#123;&quot;color_message&quot;: color_message&#125;) await self.startup(sockets=sockets) if self.should_exit: return await self.main_loop() await self.shutdown(sockets=sockets) message = &quot;Finished server process [%d]&quot; color_message = &quot;Finished server process [&quot; + click.style(&quot;%d&quot;, fg=&quot;cyan&quot;) + &quot;]&quot; logger.info(message, process_id, extra=&#123;&quot;color_message&quot;: color_message&#125;) æˆ‘ä»¬çœ‹çœ‹ startup() ï¼Œmain_loop() å’Œ shutdown()é‡Œé¢æœ‰ä»€ä¹ˆ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162async def startup(self, sockets: list[socket.socket] | None = None) -&gt; None: await self.lifespan.startup() if self.lifespan.should_exit: self.should_exit = True return config = self.config def create_protocol( _loop: asyncio.AbstractEventLoop | None = None, ) -&gt; asyncio.Protocol: return config.http_protocol_class( # type: ignore[call-arg] config=config, server_state=self.server_state, app_state=self.lifespan.state, _loop=_loop, ) loop = asyncio.get_running_loop() listeners: Sequence[socket.SocketType] if sockets is not None: # pragma: full coverage # å½“ç”¨æˆ·ä¼ socketè¿‡æ¥çš„æ—¶å€™ï¼š åŸºäºè¯¥scoketå’Œcreate_protocolåˆ›å»ºæœåŠ¡ï¼Œ # å¦‚æœæ˜¯å¤šè¿›ç¨‹ä¸”æ˜¯Windowsç³»ç»Ÿï¼Œ åˆ™è¦æ˜¾ç¤ºçš„å…±äº«socketã€‚ ... elif config.fd is not None: # pragma: py-win32 # å½“ç”¨æˆ·ä¼ æ–‡ä»¶æè¿°ç¬¦çš„æ—¶å€™ï¼š åŸºäºè¯¥æ–‡ä»¶æè¿°ç¬¦è·å–scoketï¼Œ å¹¶é€šè¿‡è¯¥socket # å’Œcreate_protocolåˆ›å»ºæœåŠ¡ã€‚ ... elif config.uds is not None: # pragma: py-win32 # å½“ç”¨æˆ·ä¼ unix domain socketçš„æ—¶å€™: åŸºäºunix domain socketå’Œ # create_protocolåˆ›å»ºæœåŠ¡ã€‚ ... else: # å½“ç”¨æˆ·ä¼ hostå’Œportå‚æ•°çš„æ—¶å€™: åŸºäºhostå’Œportå’Œcreate_protocolåˆ›å»ºæœåŠ¡ã€‚ try: server = await loop.create_server( create_protocol, host=config.host, port=config.port, ssl=config.ssl, backlog=config.backlog, ) except OSError as exc: logger.error(exc) await self.lifespan.shutdown() sys.exit(1) assert server.sockets is not None listeners = server.sockets self.servers = [server] if sockets is None: self._log_started_message(listeners) else: # We&#x27;re most likely running multiple workers, so a message has already been # logged by `config.bind_socket()`. pass # pragma: full coverage self.started = True æ¯æ¬¡å¾ªç¯æ‰§è¡Œçš„æ—¶å€™éƒ½ä¼šè°ƒç”¨on_tickæ–¹æ³•ï¼Œ è¯¥æ–¹æ³•ä¸»è¦æ˜¯è¿›è¡ŒæœåŠ¡ç»Ÿè®¡ä»¥åŠåˆ¤æ–­å•¥æ—¶å€™å¯ä»¥é€€å‡ºæœåŠ¡, æ¯”å¦‚è¯·æ±‚æ€»æ•°è¶…è¿‡é…ç½®çš„é™åˆ¶æ•°ï¼Œ æˆ–è€…æ”¶åˆ°ä¿¡å·ï¼ŒæŠŠå˜é‡should_exitè®¾ç½®ä¸ºTrueç­‰ç­‰ 123456789async def main_loop(self) -&gt; None: counter = 0 should_exit = await self.on_tick(counter) # æ˜¯ä¸ªæ­»å¾ªç¯ï¼Œé˜²æ­¢ä¸»ç¨‹åºé€€å‡º while not should_exit: counter += 1 counter = counter % 864000 await asyncio.sleep(0.1) should_exit = await self.on_tick(counter) å¦‚æœåœ¨å¾ªç¯ä¸­åˆ¤æ–­ç¨‹åºéœ€è¦è¿›è¡Œé€€å‡º, å°±ä¼šè¿›å…¥é€€å‡ºé€»è¾‘shutdown 123456789101112131415161718192021222324252627282930313233async def shutdown(self, sockets=None): logger.info(&quot;Shutting down&quot;) # å…³é—­socketï¼Œ ä¸è®©æœ‰æ–°çš„è¿æ¥å»ºç«‹ for server in self.servers: server.close() for sock in sockets or []: sock.close() for server in self.servers: await server.wait_closed() # å…³é—­å·²ç»åˆ›å»ºçš„è¿æ¥ï¼Œ å¹¶ç­‰å¾…ä»–ä»¬å¤„ç†å®Œæ¯• for connection in list(self.server_state.connections): connection.shutdown() await asyncio.sleep(0.1) # ç­‰å¾…è¿æ¥å…³é—­æˆ–è€…ç”¨æˆ·å¼ºåˆ¶å…³é—­ if self.server_state.connections and not self.force_exit: msg = &quot;Waiting for connections to close. (CTRL+C to force quit)&quot; logger.info(msg) while self.server_state.connections and not self.force_exit: await asyncio.sleep(0.1) # ç­‰å¾…åå°ä»»åŠ¡å®Œæˆæˆ–è€…ç”¨æˆ·å¼ºåˆ¶å…³é—­ if self.server_state.tasks and not self.force_exit: msg = &quot;Waiting for background tasks to complete. (CTRL+C to force quit)&quot; logger.info(msg) while self.server_state.tasks and not self.force_exit: await asyncio.sleep(0.1) # é€šè¿‡lifespanå‘Šè¯‰ASGIåº”ç”¨ç¨‹åºå³å°†å…³é—­ if not self.force_exit: await self.lifespan.shutdown() å¯åŠ¨æµç¨‹å›¾","tags":["python","uvicron"]},{"title":"Python ORM é›†æˆ","path":"/2023/06/25/Python ORM é›†æˆ/","content":"python å¸¸ç”¨çš„ ORM æ¡†æ¶é flask_sqlalchemy è«å±ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥è‡ªå·±ç›´æ¥æ ¹æ® sqlalchemy è¿›è¡Œå°è£… flask_sqlalchemy&#x3D;&#x3D;3.0.5 pymysql&#x3D;&#x3D;1.1.0 ç›®å½•ç»“æ„ 1234567891011121314151617flask_demo:\t-- api: -- file -- file.py -- user -- user.py -- __init__.py\t-- utils -- log.py -- database.py -- restful.py\t-- model -- user.py\t-- service -- user.py\t-- manage.py\t-- requirements.txt ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960utils/database.pyfrom contextlib import contextmanagerfrom flask_sqlalchemy import SQLAlchemyclass MySQLAlchemy(SQLAlchemy): @contextmanager def auto_commit(self): try: yield self.session.commit() except Exception as e: self.session.rollback() raise edb = MySQLAlchemy()model/user.pyfrom model.base import HasTime, AutoincrementId, BaseTablefrom sqlalchemy import Column, String, SMALLINTclass User(BaseTable, HasTime, AutoincrementId): __tablename__ = &quot;user&quot; name = Column(String(10)) email = Column(String(50), nullable=False, unique=True) role = Column(String(10), nullable=False, default=&quot;user&quot;) delete_status = Column(SMALLINT, nullable=False, default=0) service/user.pyfrom model.user import Userclass UserService(object): @staticmethod def query_by_id(user_id: int) -&gt; dict: user = User.query.filter_by(id=user_id).first() return user.to_dict()api/user/user.pyimport loggingfrom flask import Blueprintfrom service.user import UserServicefrom uitls.restful import JsonResfrom uitls.log import log_requestbp = Blueprint(&#x27;user&#x27;, __name__, url_prefix=&quot;/user&quot;)LOG = logging.getLogger(__name__)@bp.route(&#x27;/get&#x27;, methods=[&#x27;GET&#x27;])@log_request()def get_user(): user = UserService.query_by_id(1) return JsonRes(200, True, user)api/__init__.py create_app æ–¹æ³•ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹ 1234567891011sql_config = &#123; &quot;SQLALCHEMY_DATABASE_URI&quot;: &quot;mysql+pymysql://root:root@localhost:3306/flask_demo?charset=utf8&quot;, &quot;SQLALCHEMY_TRACK_MODIFICATIONS&quot;: False, &quot;SQLALCHEMY_ECHO&quot;: False, &quot;SQLALCHEMY_POOL_SIZE&quot;: 10, &quot;SQLALCHEMY_POOL_TIMEOUT&quot;: 60, &quot;SQLALCHEMY_POOL_RECYCLE&quot;: 600 &#125; app.config.update(sql_config) db.init_app(app)","tags":["python"]},{"title":"Python flask æ¡†æ¶","path":"/2023/05/22/Python flask æ¡†æ¶/","content":"å†™ä¸€ä¸ªé€šç”¨çš„å°å‹ flask æ¡†æ¶ ç›®å½•ç»“æ„ 12345678910flask_demo:\t-- api: -- file -- file.py -- __init__.py\t-- utils -- log.py -- restful.py\t-- manage.py\t-- requirements.txt åŸºå‡†ä»£ç api/__init__.py1234567891011121314151617from flask import Flask, Blueprintfrom flask_cors import CORSfrom api.file.file import bp as file_bpdef create_app(): setup_log(log_level=&quot;debug&quot;, log_handler=&quot;file&quot;, log_dir=&quot;./logs&quot;, log_file_name=&quot;app.log&quot;) app = Flask(__name__) CORS(app) app_bp = Blueprint(&#x27;api&#x27;, __name__, url_prefix=&#x27;/api&#x27;) app_bp.register_blueprint(file_bp) app.register_blueprint(app_bp) return app utils/log.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import loggingimport logging.handlersimport os.pathfrom functools import wrapsfrom flask import requestDEBUG_LOG_FORMAT = &#x27;%(threadName)s %(thread)s %(asctime)s.%(msecs)03d %(process)d %(levelname)s %(name)s &#x27; \\ &#x27;%(funcName)s %(lineno)d [-] %(message)s&#x27;INFO_LOG_FORMAT = &#x27;%(threadName)s %(thread)s %(asctime)s.%(msecs)03d %(process)d %(levelname)s %(name)s &#x27; \\ &#x27;%(lineno)d [-] %(message)s&#x27;def setup_log(log_level, log_handler, log_dir, log_file_name, backupCount=1): logger = logging.getLogger() if log_level == &quot;DEBUG&quot;: logger.setLevel(logging.DEBUG) formatter = logging.Formatter(DEBUG_LOG_FORMAT) else: logger.setLevel(logging.INFO) formatter = logging.Formatter(INFO_LOG_FORMAT) if log_handler == &quot;file&quot;: if not os.path.exists(log_dir): os.makedirs(log_dir) loghandler = logging.handlers.RotatingFileHandler( filename=os.path.join(log_dir, log_file_name), maxBytes=1000000000, backupCount=backupCount) loghandler.setFormatter(formatter) else: loghandler = logging.StreamHandler() loghandler.setFormatter(formatter) logger.addHandler(loghandler) return loggerdef log_request(f): @wraps(f) def wrapsed(*args, **kwargs): log = logging.getLogger(__name__) log.info(&#x27;API request url %s&#x27;, request.url) if request.query_string: log.info(&#x27;API query string %s&#x27;, request.query_string) log.info(&#x27;API request method %s&#x27;, request.method) if request.method == &quot;POST&quot;: log.info(&quot;API POST data %s&quot;, request.json) if request.method == &quot;PUT&quot;: log.info(&quot;API PUT data %s&quot;, request.json) log.debug(&#x27;API request environ %s&#x27;, request.environ) return f(*args, **kwargs) return wrapsed utils/restful.py1234567891011121314151617181920212223242526272829303132333435import datetimeimport jsonfrom flask import Response_SIMPLE_TYPE = (str, int, type(None), bool, float)def json_encoder(value): if isinstance(value, _SIMPLE_TYPE): return value if isinstance(value, datetime.datetime): return value.isoformat() + &quot;Z&quot; elif isinstance(value, Exception): return &#123; &quot;exception&quot;: value.__class__.__name__, &quot;message&quot;: str(value) &#125;class JsonRes(Response): def __init__(self, code=200, status=True, data=None, error=None): self.res = &#123; &#x27;code&#x27;: code, &#x27;status&#x27;: status, &#125; if data is not None: self.res[&#x27;data&#x27;] = data if error is not None: self.res[&#x27;error&#x27;] = error content = json.dumps(self.res, default=json_encoder) try: super().__init__(content, status=code, mimetype=&quot;application/json&quot;) except TypeError: super(JsonRes, self).__init__(content, status=code, mimetype=&quot;application/json&quot;) manage.py123456from api import create_appapp = create_app()if __name__ == &#x27;__main__&#x27;: app.run(debug=True) file.py123456789101112131415import osfrom flask import Blueprint, requestfrom uitls.api_response import APIResponsefrom uitls.log import log_requestbp = Blueprint(&#x27;file&#x27;, __name__, url_prefix=&quot;/file&quot;)logger = logging.get_logger(__name__)@bp.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])@log_requestdef hello(): logger.info(&quot;hello world&quot;) return JsonRes(200, True, &#123;&#x27;hi&#x27;: &#x27;hi&#x27;&#125;)","tags":["python"]},{"title":"Python celery é›†æˆ","path":"/2023/05/22/Python celery é›†æˆ/","content":"celery&#x3D;&#x3D;5.2.7, redis&#x3D;&#x3D;4.5.5 ç›®å½•ç»“æ„ 123456789101112flask_demo:\t-- api: -- celery -- celery.py -- file -- file.py -- __init__.py\t-- utils -- log.py -- restful.py\t-- manage.py\t-- requirements.txt åœ¨ api/__init__.py ä¸­æ·»åŠ ä»¥ä¸‹æ–¹æ³• 1234567891011121314151617181920212223242526def celery_init_app(app): celery_app = Celery(app.name) celery_app.config_from_object(app.config[&quot;CELERY&quot;]) celery_app.set_default() app.extensions[&quot;celery&quot;] = celery_app return celery_appdef creat_app():\t...some code\tapp = Flask(__name__) app.config.from_mapping( CELERY=dict( broker_url=&quot;redis://localhost:6379/0&quot;, result_backend=&quot;redis://localhost:6379/1&quot;, task_ignore_result=True, task_serializer=&#x27;json&#x27;, accept_content=[&#x27;json&#x27;], result_serializer=&#x27;json&#x27; ), ) app.config.from_prefixed_env() celery_init_app(app) ... another code åœ¨ app.py 12app = create_app()celery = app.extensions[&quot;celery&quot;] åœ¨ utils/tasks.py ä¸­æ·»åŠ ä»»åŠ¡ ä¸è¦åœ¨ task æ–¹æ³•ä¸­è°ƒç”¨å…¶ä»–ç±»çš„æ–¹æ³•ï¼Œtask æ–¹æ³•æ˜¯å¼‚æ­¥ä»»åŠ¡ï¼Œè°ƒç”¨å…¶ä»–æ–¹æ³•ä¼šæŠ¥é”™ 1234567891011from __future__ import absolute_import, unicode_literalsimport timefrom celery import shared_task@shared_task(ignore_result=False)def test1(x, y): time.sleep(1) return x + y æ³¨æ„ï¼šç›´æ¥æŒ‰ç…§ flask å®˜æ–¹æ–‡æ¡£é…ç½®ä¼šæœ‰é”™è¯¯å‡ºç° celery å¯åŠ¨æ–¹å¼ 123456789101112131415# windows åªèƒ½ç”¨ threads å¯åŠ¨ï¼Œå¦åˆ™ä»»åŠ¡æ— æ³•æ‰§è¡Œcelery -A app.celery worker -c 4 -l info -P threadså‚æ•°è¯´æ˜ï¼š\tapp:celery # app æŒ‡çš„æ˜¯ app.py celery æ˜¯ app.py ä¸­çš„ celery å¯¹è±¡\t-P # å¯åŠ¨æ–¹å¼: preforkï¼šé»˜è®¤çš„å¹¶å‘æ–¹å¼ï¼Œå³å¤šè¿›ç¨‹çš„æ–¹å¼ã€‚ eventletï¼šä½¿ç”¨eventletæ–¹å¼å¯åŠ¨workerã€‚ geventï¼šä½¿ç”¨geventæ–¹å¼å¯åŠ¨workerã€‚ soloï¼šå•è¿›ç¨‹çš„æ–¹å¼ã€‚ threadsï¼šä½¿ç”¨çº¿ç¨‹çš„æ–¹å¼\t-l # log çº§åˆ«\t-c # worker æ•°é‡\tå½“ -P æŒ‡å®šä¸º gevent æˆ– eventlet æ—¶ï¼Œéœ€è¦å®‰è£…å¯¹åº”çš„ä¾èµ– celery task çš„ç»“æœé»˜è®¤å­˜å‚¨æ—¶é—´æ˜¯ 1 å¤©ï¼Œå¯ä»¥é€šè¿‡ result_expires é…ç½®","tags":["python"]},{"title":"Pythonæ—¥å¿—jsonæ ¼å¼","path":"/2023/05/22/Pythonæ—¥å¿—jsonæ ¼å¼/","content":"python åœ¨å·¥ä½œä¸­çš„ log æ—¥å¿—ä¸€èˆ¬æ˜¯ä»¥ç‰¹æ®Šç¬¦å·åˆ†å¼€çš„æ–¹å¼ï¼Œè¿™æ ·çš„å½¢å¼æ–¹ä¾¿ debug æŸ¥é˜…ï¼Œä½†æ˜¯å¹¶ä¸åˆ©äºæ•°æ®å¤„ç†ä¸åˆ†æã€‚json æ ¼å¼å°±å¾ˆä¸é”™ï¼Œå¯ä»¥æ›´å¥½åœ°ç»„ç»‡ã€åˆ†æå’Œåˆ©ç”¨æ—¥å¿—æ•°æ®ï¼Œä»è€Œä¸ºåº”ç”¨ç¨‹åºçš„è°ƒè¯•ã€æ•…éšœæ’æŸ¥å’Œæ€§èƒ½ä¼˜åŒ–æä¾›æ›´å¤šçš„æ´å¯ŸåŠ› ç¤ºä¾‹è¦æ±‚ï¼šå°† flask çš„æ¯ä¸ªè¯·æ±‚éƒ½è®°å½•ä¸‹æ¥ log.py éœ€è¦å®‰è£… pip install python-json-logger ä¸å®‰è£… python-json-logger ä¹Ÿå¯ä»¥å®ç°ï¼Œåªè¦å°† JSON_LOG_FORMATTER å†™æˆ json å­—ç¬¦ä¸²çš„æ ¼å¼ï¼Œæˆ–è€…ä½¿ç”¨json.dumps() ä½ è¦è¾“å‡ºçš„å­—æ®µå³å¯ï¼Œä½†æ˜¯è¿™ç§æ–¹å¼æ”¹å†™çš„ json æ ¼å¼ key å’Œ value å›ºå®šä¸º string ç±»å‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import loggingimport osimport timefrom functools import wrapsfrom flask import requestfrom pythonjsonlogger import jsonloggerJSON_LOG_FORMATTER = &quot;%(appName)s %(service)s %(asctime)s %(levelname)s %(message)s %(request)s %(response)s %(rt)s&quot;class JSONFilter(logging.Filter): rt = 0 appName = &quot;myapp&quot; response = &#123;&#125; def request_parse(self): params = &#123;&#125; if request.method == &quot;GET&quot;: params = request.args.to_dict() elif request.method == &quot;POST&quot; or request.method == &quot;PUT&quot;: if request.form: params = request.form.to_dict() else: params = request.get_json() return params def filter(self, record): record.message = record.msg record.service = f&quot;&#123;request.method&#125; &#123;request.path&#125;&quot; record.appName = self.appName record.rt = self.rt record.request = self.request_parse() record.response = self.response return Truedef make_dirs(path): if not os.path.exists(path): os.makedirs(path) return pathdef set_monitor_logger(log_path, name): logger = logging.getLogger(name) logger.setLevel(logging.DEBUG) formatter = jsonlogger.JsonFormatter(JSON_LOG_FORMATTER) json_filter = JSONFilter() logger.addFilter(json_filter) handler = logging.StreamHandler() handler.setFormatter(formatter) file_handler = logging.FileHandler(os.path.join(make_dirs(log_path), f&quot;&#123;name&#125;.log&quot;)) file_handler.setFormatter(formatter) logger.addHandler(handler) logger.addHandler(file_handler) return loggermonitor_logger = set_monitor_logger(&quot;monitor&quot;)def log_request(func): @wraps(func) def wrapped(*args, **kwargs): _filter = monitor_logger.filters[0] start_time = time.time() response = func(*args, **kwargs) _filter.rt = round(time.time() - start_time, 3) _filter.response = response.json monitor_logger.info(&quot;&quot;) return response return wrapped xxxxxxxxxx sql_config &#x3D; { â€œSQLALCHEMY_DATABASE_URIâ€: â€œmysql+pymysql:&#x2F;&#x2F;root:root@localhost:3306&#x2F;flask_demo?charset&#x3D;utf8â€, â€œSQLALCHEMY_TRACK_MODIFICATIONSâ€: False, â€œSQLALCHEMY_ECHOâ€: False, â€œSQLALCHEMY_POOL_SIZEâ€: 10, â€œSQLALCHEMY_POOL_TIMEOUTâ€: 60, â€œSQLALCHEMY_POOL_RECYCLEâ€: 600 } app.config.update(sql_config) db.init_app(app)python","tags":["python"]},{"title":"Python æ–‡ä»¶ä¸Šä¼ ","path":"/2023/05/19/Python-æ–‡ä»¶ä¸Šä¼ /","content":"é’ˆå¯¹å¤§æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼ ç„¶ååˆå¹¶å¯ä»¥ä½¿ç”¨å‰ç«¯è§£å†³æ–¹æ¡ˆ webuploader ç»„ä»¶ åç«¯æ¥å£1234567891011121314151617181920212223242526272829303132333435363738394041import osfrom flask import Blueprint, requestfrom uitls.api_response import JsonResfrom uitls.log import log_requestbp = Blueprint(&#x27;file&#x27;, __name__, url_prefix=&quot;/file&quot;)@bp.route(&#x27;/upload/accept&#x27;, methods=[&#x27;POST&#x27;])@log_request()def upload(): upload_file = request.files[&#x27;file&#x27;] task = request.form.get(&#x27;task_id&#x27;) chunk = request.form.get(&#x27;chunk&#x27;, 0) filename = &#x27;%s%s&#x27; % (task, chunk) upload_file.save(&#x27;./upload/%s&#x27; % filename) return JsonRes(200, True, &#123;&#x27;filename&#x27;: filename&#125;)@bp.route(&quot;/upload/complete&quot;, methods=[&#x27;GET&#x27;])@log_request()def upload_complete(): target_filename = request.args.get(&#x27;filename&#x27;) task = request.args.get(&#x27;task_id&#x27;) chunk = 0 with open(&#x27;./upload/%s&#x27; % target_filename, &#x27;wb&#x27;) as target_file: while True: try: filename = &#x27;./upload/%s%d&#x27; % (task, chunk) source_file = open(filename, &#x27;rb&#x27;) target_file.write(source_file.read()) source_file.close() except IOError: break chunk += 1 os.remove(filename) return JsonRes(200, True) å‰ç«¯é¡µé¢12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script src=&quot;../static/jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../static/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../static/webuploader/webuploader.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../static/webuploader/webuploader.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../static/bootstrap/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div id=&quot;picker&quot;&gt;è¯·é€‰æ‹©&lt;/div&gt; &lt;!-- ä¸Šä¼ æŒ‰é’®ï¼Œå¿…é¡»æŒ‡å®šidé€‰æ‹©å™¨çš„å€¼ --&gt; &lt;div class=&quot;progress&quot;&gt; &lt;!-- è¿›åº¦æ¡ --&gt; &lt;div class=&quot;progress-bar progress-bar-striped active&quot; role=&quot;progressbar&quot; style=&quot;width:0%;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() &#123; var task_id = WebUploader.Base.guid(); //äº§ç”Ÿtask_id var uploader = WebUploader.create(&#123; //åˆ›å»ºä¸Šä¼ æ§ä»¶ swf: &#x27;../static/webuploader/Uploader.swf&#x27;, //swfä½ç½®ï¼Œè¿™ä¸ªå¯èƒ½ä¸flashæœ‰å…³ server: &#x27;http://localhost:5000/api/file/upload/accept&#x27;, //æ¥æ”¶æ¯ä¸€ä¸ªåˆ†ç‰‡çš„æœåŠ¡å™¨åœ°å€ pick: &#x27;#picker&#x27;, //å¡«ä¸Šä¼ æŒ‰é’®çš„idé€‰æ‹©å™¨å€¼ auto: true, //é€‰æ‹©æ–‡ä»¶åï¼Œæ˜¯å¦è‡ªåŠ¨ä¸Šä¼  chunked: true, //æ˜¯å¦åˆ†ç‰‡ chunkSize: 20 * 1024 * 1024, //æ¯ä¸ªåˆ†ç‰‡çš„å¤§å°ï¼Œè¿™é‡Œä¸º20M chunkRetry: 3, //æŸåˆ†ç‰‡è‹¥ä¸Šä¼ å¤±è´¥ï¼Œé‡è¯•æ¬¡æ•° threads: 1, //çº¿ç¨‹æ•°é‡ï¼Œè€ƒè™‘åˆ°æœåŠ¡å™¨ï¼Œè¿™é‡Œå°±é€‰äº†1 duplicate: true, //åˆ†ç‰‡æ˜¯å¦è‡ªåŠ¨å»é‡ formData: &#123; //æ¯æ¬¡ä¸Šä¼ åˆ†ç‰‡ï¼Œä¸€èµ·æºå¸¦çš„æ•°æ® task_id: task_id, &#125;, &#125;); uploader.on(&#x27;startUpload&#x27;, function() &#123; //å¼€å§‹ä¸Šä¼ æ—¶ï¼Œè°ƒç”¨è¯¥æ–¹æ³• $(&#x27;.progress-bar&#x27;).css(&#x27;width&#x27;, &#x27;0%&#x27;); $(&#x27;.progress-bar&#x27;).text(&#x27;0%&#x27;); &#125;); uploader.on(&#x27;uploadProgress&#x27;, function(file, percentage) &#123; //ä¸€ä¸ªåˆ†ç‰‡ä¸Šä¼ æˆåŠŸåï¼Œè°ƒç”¨è¯¥æ–¹æ³• $(&#x27;.progress-bar&#x27;).css(&#x27;width&#x27;, percentage * 100 - 1 + &#x27;%&#x27;); $(&#x27;.progress-bar&#x27;).text(Math.floor(percentage * 100 - 1) + &#x27;%&#x27;); &#125;); uploader.on(&#x27;uploadSuccess&#x27;, function(file) &#123; //æ•´ä¸ªæ–‡ä»¶çš„æ‰€æœ‰åˆ†ç‰‡éƒ½ä¸Šä¼ æˆåŠŸï¼Œè°ƒç”¨è¯¥æ–¹æ³• //ä¸Šä¼ çš„ä¿¡æ¯ï¼ˆæ–‡ä»¶å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œæ–‡ä»¶åï¼‰ var data = &#123;&#x27;task_id&#x27;: task_id, &#x27;filename&#x27;: file.source[&#x27;name&#x27;] &#125;; $.get(&#x27;http://localhost:5000/api/file/upload/complete&#x27;, data); //ajaxæºå¸¦dataå‘è¯¥urlå‘è¯·æ±‚ $(&#x27;.progress-bar&#x27;).css(&#x27;width&#x27;, &#x27;100%&#x27;); $(&#x27;.progress-bar&#x27;).text(&#x27;ä¸Šä¼ å®Œæˆ&#x27;); &#125;); uploader.on(&#x27;uploadError&#x27;, function(file) &#123; //ä¸Šä¼ è¿‡ç¨‹ä¸­å‘ç”Ÿå¼‚å¸¸ï¼Œè°ƒç”¨è¯¥æ–¹æ³• $(&#x27;.progress-bar&#x27;).css(&#x27;width&#x27;, &#x27;100%&#x27;); $(&#x27;.progress-bar&#x27;).text(&#x27;ä¸Šä¼ å¤±è´¥&#x27;); &#125;); uploader.on(&#x27;uploadComplete&#x27;, function(file) &#123;//ä¸Šä¼ ç»“æŸï¼Œæ— è®ºæ–‡ä»¶æœ€ç»ˆæ˜¯å¦ä¸Šä¼ æˆåŠŸï¼Œè¯¥æ–¹æ³•éƒ½ä¼šè¢«è°ƒç”¨ $(&#x27;.progress-bar&#x27;).removeClass(&#x27;active progress-bar-striped&#x27;); &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; å‰ç«¯é¡µé¢ä¾èµ–çš„ js css ç­‰å¯ä»¥åœ¨ https://github.com/xinmos/xinmos.github.io/tree/master/asset/upload/ ä¸‹è½½","tags":["python"]},{"title":"Python è£…é¥°å™¨","path":"/2023/05/19/Python-è£…é¥°å™¨/","content":"åœ¨ python flask ä¸€æ–‡ä¸­ utils/log.py ä¸­å®šä¹‰äº†ä¸€ä¸ªè£…é¥°å™¨ï¼Œç”¨äºå°†æ‰€æœ‰çš„ç½‘ç»œè¯·æ±‚è®°å…¥åˆ°æ—¥å¿—ä¸­ é‚£å¦‚ä½•å®šä¹‰ä¸€ä¸ªå¸¦å‚æ•°çš„è£…é¥°å™¨å‘¢ï¼Ÿ æœ€ç®€å•çš„è£…é¥°å™¨123456789101112131415161718192021222324252627282930313233343536373839from functools import wrapsdef decorator(func): def wrapper(*args, **kwargs): # æ·»åŠ é¢å¤–çš„åŠŸèƒ½æˆ–ä¿®æ”¹è¡Œä¸º print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…&quot;) result = func(*args, **kwargs) print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…&quot;) return result return wrapperdef decorator2(func): @wraps(func) def wrapper(*args, **kwargs): # æ·»åŠ é¢å¤–çš„åŠŸèƒ½æˆ–ä¿®æ”¹è¡Œä¸º print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…&quot;) result = func(*args, **kwargs) print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…&quot;) return result return wrapper@decoratordef test1(): print(&quot;run test1&quot;)@decorator2def test2(): print(&quot;run test2&quot;)if __name__ == &#x27;__main__&#x27;: test1() print(&quot;test1 func name: &quot;, test1.__name__) test2() print(&quot;test2 func name: &quot;, test2.__name__) è¾“å‡º: 12345678åœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…run test1åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…test1 func name: wrapperåœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…run test2åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…test2 func name: test2 @wraps ä½œç”¨@wrapsæ˜¯Pythonä¸­çš„ä¸€ä¸ªè£…é¥°å™¨ï¼Œå®ƒå¯ä»¥ç”¨æ¥å°†è¢«è£…é¥°å‡½æ•°çš„å…ƒä¿¡æ¯ï¼ˆå¦‚å‡½æ•°åã€å‚æ•°åˆ—è¡¨ç­‰ï¼‰å¤åˆ¶åˆ°è£…é¥°å™¨å‡½æ•°ä¸­ï¼Œä»è€Œä½¿å¾—è£…é¥°å™¨å‡½æ•°ä¹Ÿå…·æœ‰è¢«è£…é¥°å‡½æ•°çš„å…ƒä¿¡æ¯ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œå¯ä»¥è®©è¢«è£…é¥°å‡½æ•°åœ¨ä½¿ç”¨æ—¶æ›´åŠ æ–¹ä¾¿ï¼Œå› ä¸ºå®ƒä»¬çš„å…ƒä¿¡æ¯ä¸ä¼šè¢«ä¿®æ”¹ å¸¦å‚æ•°çš„è£…é¥°å™¨åœ¨è£…é¥°å™¨çš„å¤–é¢å†åŒ…è£¹ä¸€å±‚ 1234567891011121314151617181920212223from functools import wrapsdef log_request(on=True): def decorator(func): @wraps(func) def wrapper(*args, **kwargs): print(&quot;args: on=&quot;, on) print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…&quot;) result = func(*args, **kwargs) print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…&quot;) return result return wrapper return decorator@log_request(on=False)def test(): print(&quot;run test&quot;)if __name__ == &#x27;__main__&#x27;: test() è¾“å‡ºï¼š 1234args: on= Falseåœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…run teståœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ… å¯ä»¥ä½¿ç”¨ @log_request() ä½†æ˜¯æ— æ³•ç›´æ¥ä½¿ç”¨ @log_requestï¼Œå³ä½¿ on å·²ç»è®¾ç½®äº†é»˜è®¤å€¼ã€‚ å…¼å®¹å‹è£…é¥°å™¨12345678910111213141516171819202122232425262728293031323334353637383940from functools import wrapsdef log_request(origin_func=None, on=True): def decorator(func): @wraps(func) def wrapper(*args, **kwargs): print(&quot;args: on=&quot;, on) print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…&quot;) result = func(*args, **kwargs) print(&quot;åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…&quot;) return result return wrapper if origin_func is None: return decorator else: return decorator(origin_func)@log_requestdef test(): print(&quot;run test&quot;)@log_request()def test2(): print(&quot;run test2&quot;)@log_request(on=False)def test3(): print(&quot;run test3&quot;)if __name__ == &#x27;__main__&#x27;: test() print(&quot;-------------&quot;) test2() print(&quot;-------------&quot;) test3() è¾“å‡ºï¼š 1234567891011121314args: on= Trueåœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…run teståœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…-------------args: on= Trueåœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…run test2åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…-------------args: on= Falseåœ¨è°ƒç”¨å‡½æ•°ä¹‹å‰åšä¸€äº›äº‹æƒ…run test3åœ¨è°ƒç”¨å‡½æ•°ä¹‹ååšä¸€äº›äº‹æƒ…","tags":["python"]},{"title":"Python Asyncio","path":"/2023/05/19/Python-Asyncio/","content":"åç¨‹ ä¸€ä¸ªæŠ½è±¡æ¦‚å¿µï¼Œåœ¨è®¡ç®—æœºä¸­ä¸å­˜åœ¨ åç¨‹ï¼ˆCoroutioneï¼‰ï¼Œä¹Ÿå¯ä»¥è¢«ç§°ä¸ºå¾®çº¿ç¨‹ï¼Œæ˜¯ä¸€ç§ç”¨æˆ·æ€å†…çš„ä¸Šä¸‹æ–‡åˆ‡æ¢æŠ€æœ¯ã€‚ å®ç°æ–¹æ³• yield å…³é”®å­— asyncio è£…é¥°å™¨ï¼ˆåœ¨ py 3.4 ä¹‹åå»ºè®®ç”¨ ç¬¬ä¸‰ç§æ–¹æ³•ï¼‰ asyncã€await å…³é”®å­— yield å…³é”®å­—12345678910111213# é€šè¿‡ yield åˆ‡æ¢ä¸Šä¸‹æ–‡def func1(): yield 1 yield from func2() yield 2def func2(): yield 3 yield 4f1 = func1()for item in f1: print(item) asyncio123456789101112131415161718import asyncioasync def func1(): print(1) await asyncio.sleep(2) # é‡åˆ° IO è€—æ—¶æ“ä½œï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ° tasks ä¸­çš„å…¶ä»–ä»»åŠ¡ print(2)async def func2(): print(3) await asyncio.sleep(2) print(4)loop = asyncio.get_event_loop()tasks = [asyncio.ensure_future(func1()), asyncio.ensure_future(func2())]loop.run_until_complete(asyncio.wait(tasks))# py 3.7 ä»¥åasyncio.run(tasks) å¼‚æ­¥ç¼–ç¨‹äº‹ä»¶å¾ªç¯ç†è§£ä¸ºä¸€ä¸ªæ­»å¾ªç¯ï¼Œå»æ£€æµ‹å¹¶æ‰§è¡ŒæŸäº›ä»£ç  1234567891011121314# ä¼ªä»£ç task_list = [task1, task2,...]while True: å¯æ‰§è¡Œçš„ä»»åŠ¡åˆ—è¡¨ï¼Œå·²å®Œæˆçš„ä»»åŠ¡åˆ—è¡¨ for å°±ç»ªä»»åŠ¡ in å¯æ‰§è¡Œä»»åŠ¡åˆ—è¡¨ æ‰§è¡Œ for å·²å®Œæˆä»»åŠ¡ in å·²å®Œæˆä»»åŠ¡åˆ—è¡¨ ç§»é™¤ if å¯æ‰§è¡Œä»»åŠ¡ä¸º 0ï¼š break åç¨‹å‡½æ•° ç”¨ async def func() å®šä¹‰çš„å‡½æ•° 12345async def func(): passresult = func()# åç¨‹å‡½æ•°åªåˆ›å»ºåç¨‹å¯¹è±¡ï¼Œå‡½æ•°å†…éƒ¨ä»£ç ä¸ä¼šæ‰§è¡Œ await await + å¯ç­‰å¾…å¯¹è±¡ ï¼ˆåç¨‹å¯¹è±¡ã€Futureã€IOç­‰å¾…ï¼‰ ç­‰å¾…åé¢çš„å¯¹è±¡æ‰§è¡Œå®Œæˆååœ¨æ‰§è¡Œä¸‹ä¸€æ­¥ä»»åŠ¡ï¼ˆå•çº¿ç¨‹å†…å’Œé¡ºåºæ‰§è¡Œå·®ä¸å¤šï¼‰ 123456789101112131415import asyncioasync def func1(): print(1) await asyncio.sleep(2) # é‡åˆ° IO è€—æ—¶æ“ä½œï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ° tasks ä¸­çš„å…¶ä»–ä»»åŠ¡ print(2)async def func2(): print(3) await func1() print(4)asyncio.run(func2())# è¾“å‡º 3ï¼Œ1ï¼Œ2ï¼Œ4 Task å¯¹è±¡ åœ¨äº‹ä»¶å¾ªç¯ä¸­æ·»åŠ å¤šä¸ªä»»åŠ¡ Tasks ç”¨äºå¹¶å‘è°ƒåº¦åç¨‹ï¼Œé€šè¿‡ asyncio.create_task() çš„æ–¹å¼åˆ›å»º Task å¯¹è±¡ï¼Œè¿™æ ·å¯ä»¥è®©åç¨‹åŠ å…¥æ—¶é—´å¾ªç¯ä¸­ç­‰å¾…è¢«è°ƒåº¦æ‰§è¡Œã€‚é™¤äº†ä½¿ç”¨ asyncio.create_task() å‡½æ•°ä»¥å¤–ï¼Œè¿˜å¯åŒåº•å±‚çº§åˆ«çš„ loop.create_task() æˆ– asyncio.ensure_future() å‡½æ•°ã€‚ä¸å»ºè®®æ‰‹åŠ¨å®ä¾‹åŒ– Task å¯¹è±¡ æ³¨æ„ï¼šasyncio.create_task() åœ¨ python3.7 ä¹‹åæ‰è¢«åŠ å…¥ï¼Œè¯¥ç‰ˆæœ¬ä¹‹å‰ç”¨ asyncio.ensure_future() 12345678910111213141516171819202122232425import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;the Return&quot;async def main(): print(&quot;main start&quot;) # åˆ›å»º task å¯¹è±¡ï¼Œå°† func æ·»åŠ åˆ°äº‹ä»¶å¾ªç¯ task1 = asyncio.create_task(func()) task2 = asyncio.create_task(func()) print(&quot;main end&quot;) # å½“æŸåç¨‹é‡åˆ° é˜»å¡ï¼ˆI/Oã€sleepï¼‰ä¼šè‡ªåŠ¨åˆ‡æ¢åˆ°å…¶ä»–ä»»åŠ¡ ret1 = await task1 ret2 = await task2 print(ret1, ret2)asyncio.run(main()) ç”¨çš„å°‘ï¼Œä¸‹é¢çš„æ¯”è¾ƒå¸¸ç”¨ 123456789101112131415161718192021222324import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;the Return&quot;async def main(): print(&quot;main start&quot;) task_list = [ asyncio.create_task(func()), asyncio.create_task(func()) ] print(&quot;main end&quot;) # done ä¸ºæ‰§è¡Œå®Œä¹‹åçš„ç»“æœï¼Œpending ä¸ºæœªæ‰§è¡Œå®Œçš„ç»“æœ done, pending = await asyncio.wait(task_list) print(done, pending)asyncio.run(main()) ç¬¬ä¸‰ç§ 12345678910111213141516import asyncioasync def func(): print(1) await asyncio.sleep(2) print(2) return &quot;the Return&quot;task_list = [ func(), func()]done, pending = asyncio.run(asyncio.wait(task_list))print(done, pending) asyncio.FutureTask ç»§æ‰¿ Future å¯¹è±¡ï¼ŒTask å¯¹è±¡å†…éƒ¨ await ç»“æœçš„å¤„ç†åŸºäº Future å¯¹è±¡æ¥çš„ã€‚ 12345678async def main(): # è·å–å½“å‰äº‹ä»¶å¾ªç¯ loop = asyncio.get_running_loop() # # åˆ›å»ºä¸€ä¸ªä»»åŠ¡ï¼ˆFutureå¯¹è±¡ï¼‰ï¼Œè¿™ä¸ªä»»åŠ¡ä»€ä¹ˆéƒ½ä¸å¹²ã€‚ fut = loop.create_future() # ç­‰å¾…ä»»åŠ¡æœ€ç»ˆç»“æœï¼ˆFutureå¯¹è±¡ï¼‰ï¼Œæ²¡æœ‰ç»“æœåˆ™ä¼šä¸€ç›´ç­‰ä¸‹å»ã€‚ await futasyncio.run(main()) ç¤ºä¾‹2ï¼š 123456789101112131415161718import asyncioasync def set_after(fut): await asyncio.sleep(2) fut.set_result(&quot;666&quot;) async def main(): # è·å–å½“å‰äº‹ä»¶å¾ªç¯ loop = asyncio.get_running_loop() # åˆ›å»ºä¸€ä¸ªä»»åŠ¡ï¼ˆFutureå¯¹è±¡ï¼‰ï¼Œæ²¡ç»‘å®šä»»ä½•è¡Œä¸ºï¼Œåˆ™è¿™ä¸ªä»»åŠ¡æ°¸è¿œä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™ç»“æŸã€‚ fut = loop.create_future() # åˆ›å»ºä¸€ä¸ªä»»åŠ¡ï¼ˆTaskå¯¹è±¡ï¼‰ï¼Œç»‘å®šäº†set_afterå‡½æ•°ï¼Œå‡½æ•°å†…éƒ¨åœ¨2sä¹‹åï¼Œä¼šç»™futèµ‹å€¼ã€‚ # å³æ‰‹åŠ¨è®¾ç½®futureä»»åŠ¡çš„æœ€ç»ˆç»“æœï¼Œé‚£ä¹ˆfutå°±å¯ä»¥ç»“æŸäº†ã€‚ await loop.create_task(set_after(fut)) # ç­‰å¾… Futureå¯¹è±¡è·å– æœ€ç»ˆç»“æœï¼Œå¦åˆ™ä¸€ç›´ç­‰ä¸‹å» data = await fut print(data) asyncio.run(main()) Futureå¯¹è±¡æœ¬èº«å‡½æ•°è¿›è¡Œç»‘å®šï¼Œæ‰€ä»¥æƒ³è¦è®©äº‹ä»¶å¾ªç¯è·å–Futureçš„ç»“æœï¼Œåˆ™éœ€è¦æ‰‹åŠ¨è®¾ç½®ã€‚è€ŒTaskå¯¹è±¡ç»§æ‰¿äº†Futureå¯¹è±¡ï¼Œå…¶å®å°±å¯¹Futureè¿›è¡Œæ‰©å±•ï¼Œä»–å¯ä»¥å®ç°åœ¨å¯¹åº”ç»‘å®šçš„å‡½æ•°æ‰§è¡Œå®Œæˆä¹‹åï¼Œè‡ªåŠ¨æ‰§è¡Œset_resultï¼Œä»è€Œå®ç°è‡ªåŠ¨ç»“æŸã€‚ è™½ç„¶ï¼Œå¹³æ—¶ä½¿ç”¨çš„æ˜¯Taskå¯¹è±¡ï¼Œä½†å¯¹äºç»“æœçš„å¤„ç†æœ¬è´¨æ˜¯åŸºäºFutureå¯¹è±¡æ¥å®ç°çš„ã€‚ concurrent.futures.Future å’Œ asyncio.Future æ²¡æœ‰ä»»ä½•å…³ç³» ä½¿ç”¨çº¿ç¨‹æ± ã€è¿›ç¨‹æ± å®ç°å¼‚æ­¥æ“ä½œæ—¶ç”¨åˆ°çš„å¯¹è±¡ 123456789101112131415import timefrom concurrent.futures import Futurefrom concurrent.futures.thread import ThreadPoolExecutorfrom concurrent.futures.process import ProcessPoolExecutodef func(value): time.sleep(1) print(value) pool = ThreadPoolExecutor(max_workers=5)# æˆ– pool = ProcessPoolExecutor(max_workers=5)for i in range(10): fut = pool.submit(func, i) print(fut) ä¸¤ä¸ªFutureå¯¹è±¡æ˜¯ä¸åŒçš„ï¼Œä»–ä»¬æ˜¯ä¸ºä¸åŒçš„åº”ç”¨åœºæ™¯è€Œè®¾è®¡ï¼Œä¾‹å¦‚ï¼šconcurrent.futures.Futureä¸æ”¯æŒawaitè¯­æ³• ç­‰ã€‚ å®˜æ–¹æç¤ºä¸¤å¯¹è±¡ä¹‹é—´ä¸åŒï¼š unlike asyncio Futures, concurrent.futures.Future instances cannot be awaited. asyncio.Future.result() and asyncio.Future.exception() do not accept the timeout argument. asyncio.Future.result() and asyncio.Future.exception() raise an InvalidStateError exception when the Future is not done. Callbacks registered with asyncio.Future.add_done_callback() are not called immediately. They are scheduled with loop.call_soon() instead. asyncio Future is not compatible with the concurrent.futures.wait() and concurrent.futures.as_completed() functions. åœ¨Pythonæä¾›äº†ä¸€ä¸ªå°†futures.Future å¯¹è±¡åŒ…è£…æˆasyncio.Futureå¯¹è±¡çš„å‡½æ•° asynic.wrap_futureã€‚ æ¥ä¸‹é‡Œä½ è‚¯å®šé—®ï¼šä¸ºä»€ä¹ˆpythonä¼šæä¾›è¿™ç§åŠŸèƒ½ï¼Ÿ å…¶å®ï¼Œä¸€èˆ¬åœ¨ç¨‹åºå¼€å‘ä¸­æˆ‘ä»¬è¦ä¹ˆç»Ÿä¸€ä½¿ç”¨ asycio çš„åç¨‹å®ç°å¼‚æ­¥æ“ä½œã€è¦ä¹ˆéƒ½ä½¿ç”¨è¿›ç¨‹æ± å’Œçº¿ç¨‹æ± å®ç°å¼‚æ­¥æ“ä½œã€‚ä½†å¦‚æœ åç¨‹çš„å¼‚æ­¥å’Œ è¿›ç¨‹æ± /çº¿ç¨‹æ± çš„å¼‚æ­¥ æ··æ­æ—¶ï¼Œé‚£ä¹ˆå°±ä¼šç”¨åˆ°æ­¤åŠŸèƒ½äº†ã€‚ 12345678910111213141516171819202122232425262728import timeimport asyncioimport concurrent.futuresdef func1(): # æŸä¸ªè€—æ—¶æ“ä½œ time.sleep(2) return &quot;SB&quot;async def main(): loop = asyncio.get_running_loop() # 1. Run in the default loop&#x27;s executor ( é»˜è®¤ThreadPoolExecutor ) # ç¬¬ä¸€æ­¥ï¼šå†…éƒ¨ä¼šå…ˆè°ƒç”¨ ThreadPoolExecutor çš„ submit æ–¹æ³•å»çº¿ç¨‹æ± ä¸­ç”³è¯·ä¸€ä¸ªçº¿ç¨‹å»æ‰§è¡Œfunc1å‡½æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªconcurrent.futures.Futureå¯¹è±¡ # ç¬¬äºŒæ­¥ï¼šè°ƒç”¨asyncio.wrap_futureå°†concurrent.futures.Futureå¯¹è±¡åŒ…è£…ä¸ºasycio.Futureå¯¹è±¡ã€‚ # å› ä¸ºconcurrent.futures.Futureå¯¹è±¡ä¸æ”¯æŒawaitè¯­æ³•ï¼Œæ‰€ä»¥éœ€è¦åŒ…è£…ä¸º asycio.Futureå¯¹è±¡ æ‰èƒ½ä½¿ç”¨ã€‚ fut = loop.run_in_executor(None, func1) result = await fut print(&#x27;default thread pool&#x27;, result) # 2. Run in a custom thread pool: # with concurrent.futures.ThreadPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print(&#x27;custom thread pool&#x27;, result) # 3. Run in a custom process pool: # with concurrent.futures.ProcessPoolExecutor() as pool: # result = await loop.run_in_executor( # pool, func1) # print(&#x27;custom process pool&#x27;, result)asyncio.run(main()) åº”ç”¨åœºæ™¯ï¼šå½“é¡¹ç›®ä»¥åç¨‹å¼çš„å¼‚æ­¥ç¼–ç¨‹å¼€å‘æ—¶ï¼Œå¦‚æœè¦ä½¿ç”¨ä¸€ä¸ªç¬¬ä¸‰æ–¹æ¨¡å—ï¼Œè€Œç¬¬ä¸‰æ–¹æ¨¡å—ä¸æ”¯æŒåç¨‹æ–¹å¼å¼‚æ­¥ç¼–ç¨‹æ—¶ï¼Œå°±éœ€è¦ç”¨åˆ°è¿™ä¸ªåŠŸèƒ½ï¼Œä¾‹å¦‚ï¼š 12345678910111213141516171819202122232425import asyncioimport requestsasync def download_image(url): # å‘é€ç½‘ç»œè¯·æ±‚ï¼Œä¸‹è½½å›¾ç‰‡ï¼ˆé‡åˆ°ç½‘ç»œä¸‹è½½å›¾ç‰‡çš„IOè¯·æ±‚ï¼Œè‡ªåŠ¨åŒ–åˆ‡æ¢åˆ°å…¶ä»–ä»»åŠ¡ï¼‰ print(&quot;å¼€å§‹ä¸‹è½½:&quot;, url) loop = asyncio.get_event_loop() # requestsæ¨¡å—é»˜è®¤ä¸æ”¯æŒå¼‚æ­¥æ“ä½œï¼Œæ‰€ä»¥å°±ä½¿ç”¨çº¿ç¨‹æ± æ¥é…åˆå®ç°äº†ã€‚ future = loop.run_in_executor(None, requests.get, url) response = await future print(&#x27;ä¸‹è½½å®Œæˆ&#x27;) # å›¾ç‰‡ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶ file_name = url.rsplit(&#x27;_&#x27;)[-1] with open(file_name, mode=&#x27;wb&#x27;) as file_object: file_object.write(response.content) if __name__ == &#x27;__main__&#x27;: url_list = [ &#x27;https://www3.autoimg.cn/newsdfs/g26/M02/35/A9/120x90_0_autohomecar__ChsEe12AXQ6AOOH_AAFocMs8nzU621.jpg&#x27;, &#x27;https://www2.autoimg.cn/newsdfs/g30/M01/3C/E2/120x90_0_autohomecar__ChcCSV2BBICAUntfAADjJFd6800429.jpg&#x27;, &#x27;https://www3.autoimg.cn/newsdfs/g26/M0B/3C/65/120x90_0_autohomecar__ChcCP12BFCmAIO83AAGq7vK0sGY193.jpg&#x27; ] tasks = [download_image(url) for url in url_list] loop = asyncio.get_event_loop() loop.run_until_complete( asyncio.wait(tasks) ) å¼‚æ­¥è¿­ä»£å™¨uvloopPythonæ ‡å‡†åº“ä¸­æä¾›äº†asyncioæ¨¡å—ï¼Œç”¨äºæ”¯æŒåŸºäºåç¨‹çš„å¼‚æ­¥ç¼–ç¨‹ã€‚ uvloopæ˜¯ asyncio ä¸­çš„äº‹ä»¶å¾ªç¯çš„æ›¿ä»£æ–¹æ¡ˆï¼Œæ›¿æ¢åå¯ä»¥ä½¿å¾—asyncioæ€§èƒ½æé«˜ã€‚äº‹å®ä¸Šï¼Œuvloopè¦æ¯”nodejsã€geventç­‰å…¶ä»–pythonå¼‚æ­¥æ¡†æ¶è‡³å°‘è¦å¿«2å€ï¼Œæ€§èƒ½å¯ä»¥æ¯”è‚©Goè¯­è¨€ã€‚ å®‰è£…uvloop 1pip3 install uvloop åœ¨é¡¹ç›®ä¸­æƒ³è¦ä½¿ç”¨uvloopæ›¿æ¢asyncioçš„äº‹ä»¶å¾ªç¯ä¹Ÿéå¸¸ç®€å•ï¼Œåªè¦åœ¨ä»£ç ä¸­è¿™ä¹ˆåšå°±è¡Œã€‚ 12345678import asyncioimport uvloopasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())# ç¼–å†™asyncioçš„ä»£ç ï¼Œä¸ä¹‹å‰å†™çš„ä»£ç ä¸€è‡´ã€‚# å†…éƒ¨çš„äº‹ä»¶å¾ªç¯è‡ªåŠ¨åŒ–ä¼šå˜ä¸ºuvloopasyncio.run(...) æ³¨æ„ï¼šçŸ¥åçš„asgi uvicornå†…éƒ¨å°±æ˜¯ä½¿ç”¨çš„uvloopçš„äº‹ä»¶å¾ªç¯ã€‚ å®æˆ˜æ¡ˆä¾‹å¼‚æ­¥ Rediså½“é€šè¿‡ Python å»æ“ä½œ redis æ—¶ï¼Œè¿æ¥ã€è®¾ç½®å€¼ã€è·å–å€¼ è¿™äº›éƒ½æ¶‰åŠç½‘ç»œ IO è¯·æ±‚ï¼Œä½¿ç”¨ asyncio å¼‚æ­¥çš„æ–¹å¼å¯ä»¥åœ¨ IO ç­‰å¾…æ—¶å»åšä¸€äº›å…¶ä»–ä»»åŠ¡ï¼Œä»è€Œæå‡æ€§èƒ½ å®‰è£…Pythonå¼‚æ­¥æ“ä½œredisæ¨¡å— 1pip3 install aioredis ç¤ºä¾‹1ï¼šå¼‚æ­¥æ“ä½œredisã€‚ 1234567891011121314151617181920#!/usr/bin/env python# -*- coding:utf-8 -*-import asyncioimport aioredisasync def execute(address, password): print(&quot;å¼€å§‹æ‰§è¡Œ&quot;, address) # ç½‘ç»œIOæ“ä½œï¼šåˆ›å»ºredisè¿æ¥ redis = await aioredis.create_redis(address, password=password) # ç½‘ç»œIOæ“ä½œï¼šåœ¨redisä¸­è®¾ç½®å“ˆå¸Œå€¼carï¼Œå†…éƒ¨åœ¨è®¾ä¸‰ä¸ªé”®å€¼å¯¹ï¼Œå³ï¼š redis = &#123; car:&#123;key1:1,key2:2,key3:3&#125;&#125; await redis.hmset_dict(&#x27;car&#x27;, key1=1, key2=2, key3=3) # ç½‘ç»œIOæ“ä½œï¼šå»redisä¸­è·å–å€¼ result = await redis.hgetall(&#x27;car&#x27;, encoding=&#x27;utf-8&#x27;) print(result) redis.close() # ç½‘ç»œIOæ“ä½œï¼šå…³é—­redisè¿æ¥ await redis.wait_closed() print(&quot;ç»“æŸ&quot;, address) asyncio.run(execute(&#x27;redis://47.93.4.198:6379&#x27;, &quot;root!2345&quot;)) ç¤ºä¾‹2ï¼šè¿æ¥å¤šä¸ªredisåšæ“ä½œï¼ˆé‡åˆ°IOä¼šåˆ‡æ¢å…¶ä»–ä»»åŠ¡ï¼Œæä¾›äº†æ€§èƒ½ï¼‰ã€‚ 1234567891011121314151617181920212223import asyncioimport aioredisasync def execute(address, password): print(&quot;å¼€å§‹æ‰§è¡Œ&quot;, address) # ç½‘ç»œIOæ“ä½œï¼šå…ˆå»è¿æ¥ 47.93.4.197:6379ï¼Œé‡åˆ°IOåˆ™è‡ªåŠ¨åˆ‡æ¢ä»»åŠ¡ï¼Œå»è¿æ¥47.93.4.198:6379 redis = await aioredis.create_redis_pool(address, password=password) # ç½‘ç»œIOæ“ä½œï¼šé‡åˆ°IOä¼šè‡ªåŠ¨åˆ‡æ¢ä»»åŠ¡ await redis.hmset_dict(&#x27;car&#x27;, key1=1, key2=2, key3=3) # ç½‘ç»œIOæ“ä½œï¼šé‡åˆ°IOä¼šè‡ªåŠ¨åˆ‡æ¢ä»»åŠ¡ result = await redis.hgetall(&#x27;car&#x27;, encoding=&#x27;utf-8&#x27;) print(result) redis.close() # ç½‘ç»œIOæ“ä½œï¼šé‡åˆ°IOä¼šè‡ªåŠ¨åˆ‡æ¢ä»»åŠ¡ await redis.wait_closed() print(&quot;ç»“æŸ&quot;, address) task_list = [ execute(&#x27;redis://47.93.4.197:6379&#x27;, &quot;root!2345&quot;), execute(&#x27;redis://47.93.4.198:6379&#x27;, &quot;root!2345&quot;)]asyncio.run(asyncio.wait(task_list)) å®˜ç½‘ï¼šhttps://aioredis.readthedocs.io/en/v1.3.0/start.html çˆ¬è™«123456789101112131415161718192021import aiohttpimport asyncioasync def fetch(session, url): print(&quot;å‘é€è¯·æ±‚ï¼š&quot;, url) async with session.get(url, verify_ssl=False) as response: text = await response.text() print(&quot;å¾—åˆ°ç»“æœï¼š&quot;, url, len(text)) async def main(): async with aiohttp.ClientSession() as session: url_list = [ &#x27;https://python.org&#x27;, &#x27;https://www.baidu.com&#x27;, &#x27;https://www.pythonav.com&#x27; ] tasks = [asyncio.create_task(fetch(session, url)) for url in url_list] await asyncio.wait(tasks) if __name__ == &#x27;__main__&#x27;: asyncio.run(main()) å¯¹æ¯”requests requests.post æ¯æ¬¡éƒ½ä¼šåˆ›å»ºæ–°çš„è¿æ¥ï¼Œé€Ÿåº¦è¾ƒæ…¢ã€‚å¦‚æœé¦–å…ˆåˆå§‹åŒ–ä¸€ä¸ª sessionï¼Œé‚£ä¹ˆ requests ä¼šä¿æŒè¿æ¥ï¼Œå¤§å¤§æé«˜è¯·æ±‚é€Ÿåº¦ 12session = requests.Session()# session åªå¯¹åŒä¸€ä¸ªé“¾æ¥è¯·æ±‚å¤šæ¬¡çš„åœºæ™¯ä¸‹æœ‰æ•ˆ ä¸å€ŸåŠ©å…¶ä»–ç¬¬ä¸‰æ–¹åº“çš„æƒ…å†µä¸‹ requestsï¼šåªèƒ½å‘é€åŒæ­¥è¯·æ±‚ aiohttp: åªèƒ½å‘é€å¼‚æ­¥è¯·æ±‚ httpx: æ—¢èƒ½å‘é€åŒæ­¥è¯·æ±‚ï¼Œåˆèƒ½å‘é€å¼‚æ­¥è¯·æ±‚ æ€»ç»“ å¦‚æœä½ åªå‘å‡ æ¡è¯·æ±‚ã€‚é‚£ä¹ˆä½¿ç”¨ requests æˆ–è€… httpx çš„åŒæ­¥æ¨¡å¼ï¼Œä»£ç æœ€ç®€å•ã€‚ requests æ˜¯å¦åˆ›å»ºä¸€ä¸ª session ä¿æŒè¿æ¥ï¼Œé€Ÿåº¦å·®åˆ«æ¯”è¾ƒå¤§ï¼Œåœ¨æ²¡æœ‰åçˆ¬çš„æƒ…å†µä¸‹ï¼Œåªè¿½æ±‚é€Ÿåº¦ï¼Œå»ºè®®ç”¨ requests.session () å¦‚æœä½ è¦å‘é€å¾ˆå¤šè¯·æ±‚ï¼Œä½†æ˜¯æœ‰äº›åœ°æ–¹è¦å‘é€åŒæ­¥è¯·æ±‚ï¼Œæœ‰äº›åœ°æ–¹è¦å‘é€å¼‚æ­¥è¯·æ±‚ï¼Œé‚£ä¹ˆä½¿ç”¨ httpx æœ€çœäº‹ã€‚ å¦‚æœä½ è¦å‘é€å¾ˆå¤šè¯·æ±‚ï¼Œå¹¶ä¸”è¶Šå¿«è¶Šå¥½ï¼Œé‚£ä¹ˆä½¿ç”¨ aiohttp æœ€å¿«ã€‚ é—®é¢˜è·¯å¾„1234os.path.join(cur_path, &quot;\\asdff.csv&quot;)å­—ç¬¦ä¸² &quot;\\asdff.csv&quot; ä¼šå¯¼è‡´ä»ç³»ç»Ÿæ ¹ç›®å½•å¼€å§‹åŠ è½½å½“ flask è¿è¡Œæ—¶ï¼Œos.getcwd() è·å–çš„æ—¶é¡¹ç›®æ ¹ç›®å½•","tags":["python"]}]